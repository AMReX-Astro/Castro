

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flowchart &mdash; Castro  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css?v=2e394b92" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="_static/copybutton.js?v=f281be69"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "macros": {"kth": "{{k_\\mathrm{th}}}", "gcc": "{\\mathrm{g~cm^{-3}}}", "cms": "{\\mathrm{cm~s^{-1}}}", "presunit": "{\\mathrm{dyn~cm^{-2}}}", "accelunit": "{\\mathrm{cm~s^{-2}}}", "ergg": "{\\mathrm{erg~g^{-1}}}", "Ab": "{{\\bf A}}", "eb": "{{\\bf e}}", "Fb": "{{\\bf F}}", "gb": "{{\\bf g}}", "Hb": "{{\\bf H}}", "ib": "{{\\bf i}}", "Ib": "{{\\bf I}}", "Kb": "{{\\bf K}}", "lb": "{{\\bf l}}", "Lb": "{{\\bf L}}", "nb": "{{\\bf n}}", "Pb": "{{\\bf P}}", "Qb": "{{\\bf Q}}", "rb": "{{\\bf r}}", "Rb": "{{\\bf R}}", "Sb": "{{\\bf S}}", "ub": "{{\\bf u}}", "Ub": "{{\\bf U}}", "xb": "{{\\bf x}}", "dt": "{\\Delta t}", "omegadot": "{\\dot\\omega}", "inp": "{{\\rm in}}", "outp": "{{\\rm out}}", "sync": "{{\\rm sync}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\half}", "nph": "{{n+\\myhalf}}", "kpp": "{\\ensuremath{\\kappa_{\\mathrm{P}}}}", "kpr": "{\\ensuremath{\\kappa_{\\mathrm{R}}}}", "kpf": "{\\ensuremath{\\kappa_{\\mathrm{F}}}}", "vb": "{\\boldsymbol{v}}", "vbt": "{\\widetilde{\\vb}}", "rbt": "{\\widetilde{\\rb}}", "ob": "{\\boldsymbol{\\omega}}", "nablab": "{\\boldsymbol{\\nabla}}", "avg": ["{{\\left \\langle #1 \\right \\rangle}}", 1]}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Software Design" href="software.html" />
    <link rel="prev" title="Running Options: CPUs and GPUs" href="mpi_plus_x.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


          
          
          <a href="index.html" class="icon icon-home">
            Castro
              <img src="_static/castro_logo_hot_200.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
    <div class="branch">
        Branch: <a href="../FlowChart.html">main</a> | <a href="./FlowChart.html">development</a>
    </div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Castro basics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction to Castro</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputs.html">Input Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpi_plus_x.html">Running Options: CPUs and GPUs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Flowchart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#main-driverall-time-integration-methods">Main Driver—All Time Integration Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#strang-ctu-evolution">Strang+CTU Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#single-step-flowchart">Single Step Flowchart</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sdc-evolution">SDC Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sdc-single-iteration-flowchart">SDC Single Iteration Flowchart</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#simplified-sdc-evolution">Simplified-SDC Evolution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simplified-sdc-hydro-advance">Simplified_SDC Hydro Advance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="software.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPU Programming Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="problem_setups.html">Distributed Problem Setups</a></li>
<li class="toctree-l1"><a class="reference internal" href="timestepping.html">Timestepping and Retries</a></li>
<li class="toctree-l1"><a class="reference internal" href="creating_a_problem.html">Setting Up Your Own Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Outputting</a></li>
<li class="toctree-l1"><a class="reference internal" href="regridding.html">Regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Castro reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="build_system.html">Build System Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hydrodynamics.html">Hydrodynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="hse.html">Hydrostatic Equilibrium</a></li>
<li class="toctree-l1"><a class="reference internal" href="EOS.html">Equation of State</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactions.html">Reactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="mhd.html">MHD</a></li>
<li class="toctree-l1"><a class="reference internal" href="gravity.html">Gravity</a></li>
<li class="toctree-l1"><a class="reference internal" href="diffusion.html">Thermal Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotation.html">Rotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="sponge.html">Sponge</a></li>
<li class="toctree-l1"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMR.html">Adaptive Mesh Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConvertCheckpoint.html">Checkpoint Embiggener</a></li>
<li class="toctree-l1"><a class="reference internal" href="self_consistent_field.html">Self-Consistent Field Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="MAESTRO_restart.html">Restarting from Maestro</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development Best Practices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="filelist.html">File list</a></li>
<li class="toctree-l1"><a class="reference internal" href="classlist.html">Class list</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Castro</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Flowchart</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/FlowChart.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="flowchart">
<span id="sec-flowchart"></span><h1>Flowchart<a class="headerlink" href="#flowchart" title="Link to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>There are several different time-evolution methods currently
implemented in Castro. As best as possible, they share the same
driver routines and use preprocessor or runtime variables to separate
the different code paths.  These fall into two categories:</p>
<ul id="index-0">
<li><p>Strang+CTU: the Strang evolution does the burning on the
state for <span class="math notranslate nohighlight">\(\Delta t/2\)</span>, then updates the hydrodynamics using the
burned state, and then does the final <span class="math notranslate nohighlight">\(\Delta t/2\)</span> burning. No
explicit coupling of the burning and hydro is done.  This code
path uses the corner-transport upwind (CTU) method (the unsplit,
characteristic tracing method of <span id="id1">[<a class="reference internal" href="zreferences.html#id12" title="P. Colella. Multidimensional upwind methods for hyperbolic conservation laws. Journal of Computational Physics, 87:171-200, March 1990. doi:10.1016/0021-9991(90)90233-Q.">27</a>]</span>).  This is the default method.</p>
<p>The MHD solver uses this same driver.</p>
</li>
<li><p>SDC: a class of iterative methods that couples the advection and reactions
such that each process explicitly sees the effect of the other.  We have
two SDC implementations in Castro.</p>
<ul class="simple">
<li><p>The “simplified SDC” method is based on the CTU hydro update.  We
iterate over the construction of this term, using a lagged
reaction source as inputs and do the final conservative update by
integrating the reaction system using an ODE solver with the
explicit advective source included in a
piecewise-constant-in-time fastion.  This is described in <span id="id2">[<a class="reference internal" href="zreferences.html#id76" title="M. Zingale, M. P. Katz, A. Nonaka, and M. Rasmussen. An improved method for coupling hydrodynamics with astrophysical reaction networks. The Astrophysical Journal, 936(1):6, aug 2022. URL: https://dx.doi.org/10.3847/1538-4357/ac8478, doi:10.3847/1538-4357/ac8478.">15</a>]</span>.</p></li>
<li><p>The “true SDC” method.  This fully couples the hydro and reactions
to either 2nd or 4th order.  This approximates the integral in
time using a simple quadrature rule, and integrates the hydro
explicitly and reactions implicitly to the next time node.
Iterations allow each process to see one another and achieve
high-order in time convergence.  This is described in <span id="id3">[<a class="reference internal" href="zreferences.html#id49" title="M. Zingale, M. P. Katz, J. B. Bell, M. L. Minion, A. J. Nonaka, and W. Zhang. Improved Coupling of Hydrodynamics and Nuclear Reactions via Spectral Deferred Corrections. Astrophysical Journal, 886(2):105, Dec 2019. arXiv:1908.03661, doi:10.3847/1538-4357/ab4e1d.">76</a>]</span>.</p></li>
</ul>
</li>
</ul>
<p>The time-integration method used is controlled by
<code class="docutils literal notranslate"><span class="pre">castro.time_integration_method</span></code>.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">time_integration_method</span> <span class="pre">=</span> <span class="pre">0</span></code>: this is the original Castro method,
described in <span id="id4">[<a class="reference internal" href="zreferences.html#id4" title="A. S. Almgren, V. E. Beckner, J. B. Bell, M. S. Day, L. H. Howell, C. C. Joggerst, M. J. Lijewski, A. Nonaka, M. Singer, and M. Zingale. CASTRO: A New Compressible Astrophysical Solver. I. Hydrodynamics and Self-gravity. ApJ, 715:1221-1238, June 2010. doi:10.1088/0004-637X/715/2/1221.">19</a>]</span>.  This uses Strang splitting and the CTU
hydrodynamics scheme.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time_integration_method</span> <span class="pre">=</span> <span class="pre">1</span></code>: unused (in Castro 19.08 and
earlier, this was a method-of-lines integration method with Strang
splitting for reactions.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time_integration_method</span> <span class="pre">=</span> <span class="pre">2</span></code>: this is a full implementation of
the spectral deferred corrections formalism, with both 2nd and 4th
order integration implemented.  At the moment, this does not support
multilevel domains.  Note: because of differences in the interfaces with the
default Strang method, you must compile with <code class="docutils literal notranslate"><span class="pre">USE_TRUE_SDC</span> <span class="pre">=</span> <span class="pre">TRUE</span></code> for this
method to work.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time_integration_method</span> <span class="pre">=</span> <span class="pre">3</span></code>: this is the simplified SDC method
described above that uses the CTU hydro advection and an ODE
reaction solve.  Note: because this requires a different set of
state variables, you must compile with <code class="docutils literal notranslate"><span class="pre">USE_SIMPLIFIED_SDC</span> <span class="pre">=</span> <span class="pre">TRUE</span></code> for this
method to work.</p></li>
</ul>
</div></blockquote>
<div class="admonition note" id="index-1">
<p class="admonition-title">Note</p>
<p>By default, the code is compiled for Strang-split CTU evolution
(<code class="docutils literal notranslate"><span class="pre">time_integration_method</span> <span class="pre">=</span> <span class="pre">0</span></code>).  Because the size of the
different state arrays differs with the other integration schemes,
support for them needs to be compiled in, using
<code class="docutils literal notranslate"><span class="pre">USE_SIMPLIFIED_SDC=TRUE</span></code> for the simplified-SDC method
(<code class="docutils literal notranslate"><span class="pre">time_integration_method=3</span></code>) and <code class="docutils literal notranslate"><span class="pre">USE_TRUE_SDC=TRUE</span></code> for the
true SDC method (<code class="docutils literal notranslate"><span class="pre">time_integration_method</span> <span class="pre">=</span> <span class="pre">2</span></code>).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MHD and radiation are currently only supported by the Strang+CTU
evolution time integration method.</p>
</div>
<p>Several helper functions are used throughout:</p>
<ul class="simple" id="index-2">
<li><p><code class="docutils literal notranslate"><span class="pre">clean_state</span></code>:
There are many ways that the hydrodynamics state may become
unphysical in the evolution. The <code class="docutils literal notranslate"><span class="pre">clean_state()</span></code> routine
enforces some checks on the state. In particular, it</p>
<ol class="arabic simple">
<li><p>enforces that the density is above <code class="docutils literal notranslate"><span class="pre">castro.small_dens</span></code></p></li>
<li><p>enforces that the speeds in the state don’t exceed <code class="docutils literal notranslate"><span class="pre">castro.speed_limit</span></code></p></li>
<li><p>normalizes the species so that the mass fractions sum to 1</p></li>
<li><p>syncs up the linear and hybrid momenta (for <code class="docutils literal notranslate"><span class="pre">USE_HYBRID_MOMENTUM=TRUE</span></code>)</p></li>
<li><p>resets the internal energy if necessary (too small or negative)
and computes the temperature for all zones to be thermodynamically
consistent with the state.</p></li>
</ol>
</li>
</ul>
</section>
<section id="main-driverall-time-integration-methods">
<span id="flow-sec-nosdc"></span><h2>Main Driver—All Time Integration Methods<a class="headerlink" href="#main-driverall-time-integration-methods" title="Link to this heading"></a></h2>
<p>This driver supports the Strang CTU integration.
(<code class="docutils literal notranslate"><span class="pre">castro.time_integration_method</span></code> = 0)</p>
<p>The main evolution for a single step is contained in
<code class="docutils literal notranslate"><span class="pre">Castro_advance.cpp</span></code>, as <code class="docutils literal notranslate"><span class="pre">Castro::advance()</span></code>. This does
the following advancement. Note, some parts of this are only done
depending on which preprocessor directives are defined at
compile-time—the relevant directive is noted in the [ ] at the start
of each step.</p>
<ol class="arabic">
<li><p><em>Initialization</em> (<code class="docutils literal notranslate"><span class="pre">initialize_advance()</span></code>)</p>
<p>This sets up the current level for advancement. The following
actions are performend (note, we omit the actions taken for a retry,
which we will describe later):</p>
<ul class="simple">
<li><p>Do any radiation initialization.</p></li>
<li><p>Set the maximum density used for Poisson gravity tolerances.</p></li>
<li><p>Initialize all of the intermediate storage arrays (like those
that hold source terms, etc.).</p></li>
<li><p>Swap the StateData from the new to old (e.g., ensures that
the next evolution starts with the result from the previous step).</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">clean_state</span></code>.</p></li>
<li><p>Create the MultiFabs that hold the primitive variable information
for the hydro solve.</p></li>
<li><p>Zero out all of the fluxes.</p></li>
<li><p>For true SDC, initialize the data at all time nodes (see <a class="reference internal" href="#sec-flow-true-sdc"><span class="std std-ref">SDC Evolution</span></a>).</p></li>
</ul>
</li>
<li><p><em>Advancement</em></p>
<p>Call <code class="docutils literal notranslate"><span class="pre">do_advance</span></code> to take a single step, incorporating
hydrodynamics, reactions, and source terms.</p>
<p>For radiation-hydrodynamics, this step does the
advective (hyperbolic) portion of the radiation update only.
Source terms, including gravity, rotation, and diffusion are
included in this step, and are time-centered to achieve second-order
accuracy.</p>
<p id="index-3">If <code class="docutils literal notranslate"><span class="pre">castro.use_retry</span></code> is set, then we subcycle the current
step if we violated any stability criteria to reach the desired
<span class="math notranslate nohighlight">\(\Delta t\)</span>. The idea is the following: if the timestep that you
took had a timestep that was not sufficient to enforce the stability
criteria that you would like to achieve, such as the CFL criterion
for hydrodynamics or the burning stability criterion for reactions,
you can retry the timestep by setting <code class="docutils literal notranslate"><span class="pre">castro.use_retry</span></code> = 1 in
your inputs file. This will save the current state data at the
beginning of the level advance, and then if the criteria are not
satisfied, will reject that advance and start over from the old
data, with a series of subcycled timesteps that should be small
enough to satisfy the criteria. Note that this will effectively
double the memory footprint on each level if you choose to use it.
See <a class="reference internal" href="timestepping.html#ch-retry"><span class="std std-ref">Retry Mechanism</span></a> for more details on the retry mechanism.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only Strang+CTU and simplified-SDC support retries.</p>
</div>
</li>
<li><p>[POINTMASS] <em>Point mass</em></p>
<p>If <code class="docutils literal notranslate"><span class="pre">castro.point_mass_fix_solution</span></code> is set, then we
change the mass of the point mass that optionally contributes to the
gravitational potential by taking mass from the surrounding zones
(keeping the density in those zones constant).</p>
</li>
<li><p>[RADIATION] <em>Radiation implicit update</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">do_advance()</span></code> routine only handled the hyperbolic
portion of the radiation update. This step does the implicit solve
(either gray or multigroup) to advance the radiation energies to the
new time level. Note that at the moment, this is backward-difference
implicit (first-order in time) for stability.</p>
<p>This is handled by <code class="docutils literal notranslate"><span class="pre">final_radiation_call()</span></code>.</p>
</li>
<li><p>[PARTICLES] <em>Particles</em></p>
<p>If we are including passively-advected particles, they are
advanced in this step.</p>
</li>
<li><p><em>Finalize</em></p>
<p>This cleans up at the end of a step:</p>
<ul class="simple">
<li><p>Update the flux registers to account for mismatches at
coarse-fine interfaces. This cleans up the memory used during
the step.</p></li>
<li><p>Free any memory allocated for the level advance.</p></li>
</ul>
</li>
</ol>
</section>
<section id="strang-ctu-evolution">
<span id="sec-strangctu"></span><h2>Strang+CTU Evolution<a class="headerlink" href="#strang-ctu-evolution" title="Link to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">do_advance_ctu()</span></code> in <code class="docutils literal notranslate"><span class="pre">Castro_advance_ctu.cpp</span></code></p>
<p>This described the flow using Strang splitting and the CTU
hydrodynamics (or MHD) method, including gravity, rotation, and
diffusion.  This integration is selected via
<code class="docutils literal notranslate"><span class="pre">castro.time_integration_method</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>The system advancement: reactions, hydrodynamics, diffusion, rotation,
and gravity are all considered here.</p>
<p>Consider our system of equations as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial\Ub}{\partial t} = {\bf A}(\Ub) + \Rb(\Ub) + \Sb,\]</div>
<p>where <span class="math notranslate nohighlight">\({\bf A}(\Ub) = -\nabla \cdot \Fb(\Ub)\)</span>, with <span class="math notranslate nohighlight">\(\Fb\)</span> the flux vector, <span class="math notranslate nohighlight">\(\Rb\)</span> are the reaction
source terms, and <span class="math notranslate nohighlight">\(\Sb\)</span> are the non-reaction source terms, which
includes any user-defined external sources, <span class="math notranslate nohighlight">\(\Sb_{\rm ext}\)</span>. We use
Strang splitting to discretize the advection-reaction equations. In
summary, for each time step, we update the conservative variables,
<span class="math notranslate nohighlight">\(\Ub\)</span>, by reacting for half a time step, advecting for a full time
step (ignoring the reaction terms), and reacting for half a time step.
The treatment of source terms complicates this a little. The actual
update, in sequence, looks like:</p>
<div class="math notranslate nohighlight" id="equation-eq-source-correct">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-source-correct" title="Link to this equation"></a></span>\[\begin{split}\begin{aligned}
\Ub^\star &amp;= \Ub^n + \frac{\dt}{2}\Rb(\Ub^n) \\
\Ub^{n+1,(a)} &amp;= \Ub^\star + \dt\, \Sb(\Ub^\star) \\
\Ub^{n+1,(b)} &amp;= \Ub^{n+1,(a)} + \dt\, {\bf A}(\Ub^\star) \\
\Ub^{n+1,(c)} &amp;= \Ub^{n+1,(b)} + \frac{\dt}{2}\, [\Sb(\Ub^{n+1,(b)}) - \Sb(\Ub^\star)] \\
\Ub^{n+1}     &amp;= \Ub^{n+1,(c)} + \frac{\dt}{2} \Rb(\Ub^{n+1,(c)})
\end{aligned}\end{split}\]</div>
<p>Note that in the first step, we add a full <span class="math notranslate nohighlight">\(\Delta t\)</span> of the old-time
source to the state. This prediction ensures consistency when it
comes time to predicting the new-time source at the end of the update.
The construction of the advective terms, <span class="math notranslate nohighlight">\({\bf A(\Ub)}\)</span> is purely
explicit, and based on an unsplit second-order Godunov method. We
predict the standard primitive variables, as well as <span class="math notranslate nohighlight">\(\rho e\)</span>, at
time-centered edges and use an approximate Riemann solver construct
fluxes.</p>
<p>At the beginning of the time step, we assume that <span class="math notranslate nohighlight">\(\Ub\)</span> and the gravitational potential, <span class="math notranslate nohighlight">\(\phi\)</span>, are
defined consistently, i.e., <span class="math notranslate nohighlight">\(\rho^n\)</span> and <span class="math notranslate nohighlight">\(\phi^n\)</span> satisfy the Poisson equation:</p>
<div class="math notranslate nohighlight">
\[\Delta \phi^n = 4\pi G\rho^n\]</div>
<p>(see <a class="reference internal" href="gravity.html#ch-gravity"><span class="std std-ref">Gravity</span></a> for more details about how the Poisson equation is solved.)
Note that in
<a class="reference internal" href="#equation-eq-source-correct">(1)</a>, we can actually do some
sources implicitly by updating density first, and then momentum,
and then energy. This is done for rotating and gravity, and can
make the update more akin to:</p>
<div class="math notranslate nohighlight">
\[\Ub^{n+1,(c)} = \Ub^{n+1,(b)} + \frac{\dt}{2} [\Sb(\Ub^{n+1,(c)}) - \Sb(\Ub^n)]\]</div>
<p>If we are including radiation, then this part of the update algorithm
only deals with the advective / hyperbolic terms in the radiation update.</p>
<p>Here is the single-level algorithm. The goal here is to update the
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code>  <code class="docutils literal notranslate"><span class="pre">StateData</span></code> from the old to new time (see
§ <a class="reference internal" href="software.html#soft-sec-statedata"><span class="std std-ref">StateData</span></a>). We will use the following notation
here, consistent with the names used in the code:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">S_old</span></code> is a MultiFab reference to the old-time-level
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code> data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sborder</span></code> is a MultiFab that has ghost cells and is
initialized from <code class="docutils literal notranslate"><span class="pre">S_old</span></code>. This is what the hydrodynamic
reconstruction will work from.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S_new</span></code> is a MultiFab reference to the new-time-level
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code> data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">old_source</span></code> is a MultiFab reference to the old-time-level <code class="docutils literal notranslate"><span class="pre">Source_Type</span></code> data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new_source</span></code> is a MultiFab reference to the new-time-level <code class="docutils literal notranslate"><span class="pre">Source_Type</span></code> data.</p></li>
</ul>
<section id="single-step-flowchart">
<h3>Single Step Flowchart<a class="headerlink" href="#single-step-flowchart" title="Link to this heading"></a></h3>
<p>In the code, the objective is to evolve the state from the old time,
<code class="docutils literal notranslate"><span class="pre">S_old</span></code>, to the new time, <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
<ol class="arabic">
<li><p><em>Initialize</em></p>
<p>In <code class="docutils literal notranslate"><span class="pre">initialize_do_advance()</span></code>:</p>
<ol class="upperalpha simple">
<li><p>Create <code class="docutils literal notranslate"><span class="pre">Sborder</span></code>, initialized from <code class="docutils literal notranslate"><span class="pre">S_old</span></code></p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">clean_state()</span></code> to make sure the thermodynamics are in
sync, in particular, compute the temperature.</p></li>
<li><p>[<code class="docutils literal notranslate"><span class="pre">SHOCK_VAR</span></code>] zero out the shock flag.</p></li>
<li><p>Create the source corrector (if <code class="docutils literal notranslate"><span class="pre">castro.source_term_predictor</span></code> = 1)</p></li>
</ol>
</li>
<li><p><em>Do the pre-advance operations.</em></p>
<p>This is handled by <code class="docutils literal notranslate"><span class="pre">pre_advance_operators()</span></code> and the main thing
that it does is the first half of the Strang burn.</p>
<p>The steps are:</p>
<ol class="upperalpha">
<li><p><em>React</em> <span class="math notranslate nohighlight">\(\Delta t/2\)</span> [<code class="docutils literal notranslate"><span class="pre">do_old_reactions()</span></code> ]</p>
<p>Update the solution due to the effect of reactions over half a
time step. The integration method and system of equations used
here is determined by a host of runtime parameters that are part
of the Microphysics package. But the basic idea is to evolve the
energy release from the reactions, the species mass fractions,
and temperature through <span class="math notranslate nohighlight">\(\Delta t/2\)</span>.</p>
<p>Using the notation above, we begin with the time-level <span class="math notranslate nohighlight">\(n\)</span> state,
<span class="math notranslate nohighlight">\(\Ub^n\)</span>, and produce a state that has evolved only due to reactions,
<span class="math notranslate nohighlight">\(\Ub^\star\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  (\rho e)^\star &amp;= (\rho e)^n + \frac{\dt}{2} \rho H_\mathrm{nuc} \\
  (\rho E)^\star &amp;= (\rho E)^n + \frac{\dt}{2} \rho H_\mathrm{nuc} \\
  (\rho X_k)^\star &amp;= (\rho X_k)^n + \frac{\dt}{2}(\rho\omegadot_k).
\end{aligned}\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(H_\mathrm{nuc}\)</span> is the energy release (erg/g/s) over the
burn, and <span class="math notranslate nohighlight">\(\omegadot_k\)</span> is the creation rate for species <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>After exiting the burner, we call the EOS with <span class="math notranslate nohighlight">\(\rho^\star\)</span>,
<span class="math notranslate nohighlight">\(e^\star\)</span>, and <span class="math notranslate nohighlight">\(X_k^\star\)</span> to get the new temperature, <span class="math notranslate nohighlight">\(T^\star\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The density, <span class="math notranslate nohighlight">\(\rho\)</span>, does not change via reactions in the
Strang-split formulation.</p>
</div>
<p>The reaction data needs to be valid in the ghost cells, so the reactions
are applied to the entire patch, including ghost cells.</p>
<p>After reactions, <code class="docutils literal notranslate"><span class="pre">clean_state</span></code> is called.</p>
</li>
<li><p><em>Construct the gravitational potential at time <span class="math notranslate nohighlight">\(n\)</span>.</em></p>
<p>This is done by calling <code class="docutils literal notranslate"><span class="pre">construct_old_gravity()</span></code></p>
</li>
<li><p><em>Initialize ``S_new`` with the current state</em> (<code class="docutils literal notranslate"><span class="pre">Sborder</span></code>).</p></li>
</ol>
<p>At the end of this step, <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> sees the effects of the
reactions.</p>
</li>
<li><p><em>Construct time-level n sources and apply</em>
[<code class="docutils literal notranslate"><span class="pre">do_old_sources()</span></code> ]</p>
<p>The time level <span class="math notranslate nohighlight">\(n\)</span> sources are computed, and added to the
StateData <code class="docutils literal notranslate"><span class="pre">Source_Type</span></code>.</p>
<p>The sources that we deal with here are:</p>
<ol class="upperalpha">
<li><p>sponge : the sponge is a damping term added to
the momentum equation that is designed to drive the velocities to
zero over some timescale. Our implementation of the sponge
follows that of Maestro <span id="id5">[<a class="reference internal" href="zreferences.html#id9" title="A. S. Almgren, J. B. Bell, A. Nonaka, and M. Zingale. Low Mach Number Modeling of Type Ia Supernovae. III. Reactions. ApJ, 684:449-470, September 2008. doi:10.1086/590321.">20</a>]</span></p></li>
<li><p>external sources : users can define problem-specific sources
in the <code class="docutils literal notranslate"><span class="pre">problem_source.H</span></code> file. Sources for the different
equations in the conservative state vector, <span class="math notranslate nohighlight">\(\Ub\)</span>, are indexed
using the integer keys defined in <code class="docutils literal notranslate"><span class="pre">state_indices.H</span></code>
(e.g., URHO).</p>
<p>This is most commonly used for external heat sources (see the
<code class="docutils literal notranslate"><span class="pre">toy_convect</span></code> problem setup) for an example. But most
problems will not use this.</p>
</li>
<li><p>[<code class="docutils literal notranslate"><span class="pre">MHD</span></code>] thermal source: for the MHD system, we are including
the “pdV” work for the internal energy equation as a source term
rather than computing it from the Riemann problem.  This source is
computed here for the internal energy equation.</p></li>
<li><p>geometry source: this is applied only for 2-d axisymmetric data
and captures the geometric term arising from applying the
cylindrical divergence in <span class="math notranslate nohighlight">\(\nabla \cdot (\rho \Ub \Ub)\)</span> in
the momentum equation.  See <span id="id6">[<a class="reference internal" href="zreferences.html#id74" title="Aude Bernard-Champmartin, Jean-Philippe Braeunig, and Jean-Michel Ghidaglia. An Eulerian finite volume solver for multi-material fluid flows with cylindrical symmetry. Computers and Fluids, pages 7, September 2012. Publisher: Elsevier. URL: https://hal.archives-ouvertes.fr/hal-00797200 (visited on 2020-03-11), doi:10.1016/j.compfluid.2012.09.014.">2</a>]</span>.</p></li>
<li><p>[<code class="docutils literal notranslate"><span class="pre">DIFFUSION</span></code>] diffusion : thermal diffusion can be
added in an explicit formulation. Second-order accuracy is
achieved by averaging the time-level <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(n+1\)</span> terms, using
the same predictor-corrector strategy described here.</p>
<p>Note: thermal diffusion is distinct from radiation hydrodynamics.</p>
<p>Also note that incorporating diffusion brings in an additional
timestep constraint, since the treatment is explicit. See
Chapter <a class="reference internal" href="diffusion.html#ch-diffusion"><span class="std std-ref">Thermal Diffusion</span></a> for more details.</p>
</li>
<li><p>[<code class="docutils literal notranslate"><span class="pre">HYBRID_MOMENTUM</span></code>] angular momentum</p></li>
<li><p>[<code class="docutils literal notranslate"><span class="pre">GRAVITY</span></code>] gravity:</p>
<p>For full Poisson gravity, we solve for for gravity using:</p>
<div class="math notranslate nohighlight">
\[\gb^n = -\nabla\phi^n, \qquad
      \Delta\phi^n = 4\pi G\rho^n,\]</div>
<p>The construction of the form of the gravity source for the
momentum and energy equation is dependent on the parameter
<code class="docutils literal notranslate"><span class="pre">castro.grav_source_type</span></code>. Full details of the gravity
solver are given in Chapter <a class="reference internal" href="gravity.html#ch-gravity"><span class="std std-ref">Gravity</span></a>.</p>
</li>
<li><p>[<code class="docutils literal notranslate"><span class="pre">ROTATION</span></code>] rotation</p>
<p>We compute the rotational potential (for use in the energy update)
and the rotational acceleration (for use in the momentum
equation). This includes the Coriolis and centrifugal terms in a
constant-angular-velocity co-rotating frame. The form of the
rotational source that is constructed then depends on the
parameter <code class="docutils literal notranslate"><span class="pre">castro.rot_source_type</span></code>. More details are
given in Chapter <a class="reference internal" href="rotation.html#ch-rotation"><span class="std std-ref">Rotation</span></a>.</p>
</li>
</ol>
<p>The source terms here are evaluated using the post-burn state,
<span class="math notranslate nohighlight">\(\Ub^\star\)</span> (<code class="docutils literal notranslate"><span class="pre">Sborder</span></code>), and later corrected by using the
new state just before the burn, <span class="math notranslate nohighlight">\(\Ub^{n+1,(b)}\)</span>. This is compatible
with Strang-splitting, since the hydro and sources takes place
completely inside of the surrounding burn operations.</p>
<p>The old-time source terms are stored in <code class="docutils literal notranslate"><span class="pre">old_source</span></code> (and a ghost
cell fill is performed).</p>
<p>The sources are then applied to the state after the burn,
<span class="math notranslate nohighlight">\(\Ub^\star\)</span> with a full <span class="math notranslate nohighlight">\(\Delta t\)</span> weighting (this will
be corrected later). This produces the intermediate state,
<span class="math notranslate nohighlight">\(\Ub^{n+1,(a)}\)</span> (stored in <code class="docutils literal notranslate"><span class="pre">S_new</span></code>).</p>
</li>
<li><p><em>Do pre-hydro operations</em> [<code class="docutils literal notranslate"><span class="pre">pre_hydro_operators()</span></code>]</p>
<p>For Strang+CTU, nothing is done here.</p>
</li>
<li><p><em>Construct the hydro / MHD update</em> [<code class="docutils literal notranslate"><span class="pre">construct_ctu_hydro_source()</span></code>, <code class="docutils literal notranslate"><span class="pre">construct_ctu_mhd_source()</span></code>]</p>
<p>The goal is to advance our system considering only the advective
terms (which in Cartesian coordinates can be written as the
divergence of a flux).</p>
<ol class="upperalpha">
<li><p>In the Strang-split formulation, we start the reconstruction
using the state after burning, <span class="math notranslate nohighlight">\(\Ub^\star\)</span> (<code class="docutils literal notranslate"><span class="pre">Sborder</span></code>).
For the CTU method, we predict to the half-time (<span class="math notranslate nohighlight">\(n+1/2\)</span>)
to get a second-order accurate method. Note: <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> does
not know of any sources except for reactions.</p>
<p>The method done here differs depending on whether we are doing hydro or MHD.</p>
<ul>
<li><p>hydrodynamics</p>
<p>The advection step is complicated, and more detail is given in
Section <a class="reference internal" href="Hydrodynamics.html#sec-advection-step"><span class="std std-ref">Hydrodynamics Update</span></a>. Here is the summarized version:</p>
<ol class="lowerroman simple">
<li><p>Compute primitive variables.</p></li>
<li><p>Convert the source terms to those acting on primitive variables</p></li>
<li><p>Predict primitive variables to time-centered edges.</p></li>
<li><p>Solve the Riemann problem.</p></li>
<li><p>Compute fluxes and advective term.</p></li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<div><ul>
<li><p>MHD</p>
<p>The MHD update is described in <a class="reference internal" href="mhd.html#ch-mhd"><span class="std std-ref">MHD</span></a>.</p>
</li>
</ul>
<p>To start the hydrodynamics/MHD source construction, we need to know
the hydrodynamics source terms at time-level <span class="math notranslate nohighlight">\(n\)</span>, since this
enters into the prediction to the interface states. This is
essentially the same vector that was computed in the previous step,
with a few modifications. The most important is that if we set
<code class="docutils literal notranslate"><span class="pre">castro.source_term_predictor</span></code>, then we extrapolate the source
terms from <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(n+1/2\)</span>, using the change from the
previous step.</p>
<p>Note: we neglect the reaction source terms, since those are already
accounted for in the state directly, due to the Strang-splitting
nature of this method.</p>
<p>The update computed here is then immediately applied to
<code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
</div></blockquote>
<ol class="upperalpha" start="2">
<li><p><em>Clean State and check for NaNs</em> [<code class="docutils literal notranslate"><span class="pre">clean_state()</span></code>]</p>
<p>This is done on <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
</li>
<li><p><em>Update the center of mass for monopole gravity</em></p>
<p>This quantities are computed using <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
</li>
</ol>
</li>
<li><p><em>Do post-hydro operations</em> [<code class="docutils literal notranslate"><span class="pre">post_hydro_operators()</span></code>]</p>
<p>This constructs the new gravitational potential.</p>
</li>
<li><p><em>Correct the source terms with the n+1
contribution</em> [<code class="docutils literal notranslate"><span class="pre">do_new_sources</span></code> ]</p>
<p>If we are doing self-gravity, then we first compute the updated gravitational
potential using the updated density from <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
<p>Now we correct the source terms applied to <code class="docutils literal notranslate"><span class="pre">S_new</span></code> so they are time-centered.
Previously we added <span class="math notranslate nohighlight">\(\Delta t\, \Sb(\Ub^\star)\)</span> to the state, when
we really want
<span class="math notranslate nohighlight">\((\Delta t/2)[\Sb(\Ub^\star + \Sb(\Ub^{n+1,(b)})]\)</span> .</p>
<p>We start by computing the source term vector <span class="math notranslate nohighlight">\(\Sb(\Ub^{n+1,(b)})\)</span>
using the updated state, <span class="math notranslate nohighlight">\(\Ub^{n+1,(b)}\)</span>. We then compute the
correction, <span class="math notranslate nohighlight">\((\Delta t/2)[\Sb(\Ub^{n+1,(b)}) - \Sb(\Ub^\star)]\)</span> to
add to <span class="math notranslate nohighlight">\(\Ub^{n+1,(b)}\)</span> to give us the properly time-centered source,
and the fully updated state, <span class="math notranslate nohighlight">\(\Ub^{n+1,(c)}\)</span>.</p>
<p>This correction is stored
in the <code class="docutils literal notranslate"><span class="pre">new_sources</span></code> MultiFab <a class="footnote-reference brackets" href="#id9" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>In the process of updating the sources, we update the temperature to
make it consistent with the new state.</p>
</li>
<li><p><em>Do post advance operations</em> [<code class="docutils literal notranslate"><span class="pre">post_advance_operators()</span></code>]</p>
<p>This simply does the final <span class="math notranslate nohighlight">\(\dt/2\)</span> reacting on the state,
beginning with <span class="math notranslate nohighlight">\(\Ub^{n+1,(c)}\)</span> to give us the final state on
this level, <span class="math notranslate nohighlight">\(\Ub^{n+1}\)</span>.</p>
<p>This is largely the same as <code class="docutils literal notranslate"><span class="pre">strang_react_first_half()</span></code>, but
it does not currently fill the reactions in the ghost cells.</p>
</li>
<li><p><em>Finalize</em> [<code class="docutils literal notranslate"><span class="pre">finalize_do_advance()</span></code>]</p>
<p>This checks to ensure that we didn’t violate the CFL criteria
during the advance.</p>
</li>
</ol>
<p>A summary of which state is the input and which is updated for each of
these processes is presented below:</p>
<table class="docutils align-center" id="id10">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">update sequence of state arrays for Strang-CTU</span><a class="headerlink" href="#id10" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><em>step</em></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">S_old</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">Sborder</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">S_new</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ol class="arabic simple">
<li><p>init</p></li>
</ol>
</td>
<td><p>input</p></td>
<td><p>updated</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="2">
<li><p>react</p></li>
</ol>
</td>
<td></td>
<td><p>input / updated</p></td>
<td></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="3">
<li><p>old sources</p></li>
</ol>
</td>
<td></td>
<td><p>input</p></td>
<td><p>updated</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="4">
<li><p>hydro</p></li>
</ol>
</td>
<td></td>
<td><p>input</p></td>
<td><p>updated</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="5">
<li><p>clean</p></li>
</ol>
</td>
<td></td>
<td></td>
<td><p>input / updated</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="6">
<li><p>center of mass</p></li>
</ol>
</td>
<td></td>
<td></td>
<td><p>input</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="7">
<li><p>correct sources</p></li>
</ol>
</td>
<td></td>
<td></td>
<td><p>input / updated</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="8">
<li><p>react</p></li>
</ol>
</td>
<td></td>
<td></td>
<td><p>input / updated</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="sdc-evolution">
<span id="sec-flow-true-sdc"></span><h2>SDC Evolution<a class="headerlink" href="#sdc-evolution" title="Link to this heading"></a></h2>
<p>The SDC evolution is selected by <code class="docutils literal notranslate"><span class="pre">castro.time_integration_method</span> <span class="pre">=</span> <span class="pre">2</span></code>.  It
does away with Strang splitting and instead couples the reactions and hydro
together directly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At the moment, the SDC solvers do not support multilevel or AMR
simulation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code must be compiled with <code class="docutils literal notranslate"><span class="pre">USE_TRUE_SDC</span> <span class="pre">=</span> <span class="pre">TRUE</span></code> to use this
evolution type.</p>
</div>
<p>The SDC solver follows the algorithm detailed in <span id="id8">[<a class="reference internal" href="zreferences.html#id49" title="M. Zingale, M. P. Katz, J. B. Bell, M. L. Minion, A. J. Nonaka, and W. Zhang. Improved Coupling of Hydrodynamics and Nuclear Reactions via Spectral Deferred Corrections. Astrophysical Journal, 886(2):105, Dec 2019. arXiv:1908.03661, doi:10.3847/1538-4357/ab4e1d.">76</a>]</span>.
We write our evolution equation as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \Ub}{\partial t} = {\bf A}(\Ub) + {\bf R}(\Ub)\]</div>
<p>where <span class="math notranslate nohighlight">\({\bf A}(\Ub) = -\nabla \cdot {\bf F}(\Ub) + {\bf S}(\Ub)\)</span>, with the
hydrodynamic source terms, <span class="math notranslate nohighlight">\({\bf S}\)</span> grouped together with the flux divergence.</p>
<p>The SDC update looks at the solution a several time nodes (the number
depending on the desired temporal order of accuracy), and iteratively
updates the solution from node <span class="math notranslate nohighlight">\(m\)</span> to <span class="math notranslate nohighlight">\(m+1\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\avg{\Ub}^{m+1,(k+1)} = \avg{\Ub}^{m,(k+1)} &amp;+ \Delta t \left [ \avg{{\bf A}(\Ub)}^{m,(k+1)} - \avg{{\bf A}(\Ub)}^{m,(k)} \right ] \\
                                &amp;+ \Delta t \left [ \avg{{\bf R}(\Ub)}^{m+1,(k+1)} - \avg{{\bf R}(\Ub)}^{m+1,(k)} \right ] \\
                                &amp;+ \int_{t^m}^{t^{m+1}} \left [ \avg{{\bf A}(\Ub)}^{(k)} + \avg{{\bf R}(\Ub)}^{(k)} \right ] dt
\end{align}\end{split}\]</div>
<p id="index-4">Where <span class="math notranslate nohighlight">\(k\)</span> is the iteration index.  In the SDC formalism, each
iteration gains us an order of accuracy in time, up to the order with
which we discretize the integral at the end of the above expression.
We also write the conservative state as <span class="math notranslate nohighlight">\(\avg{\Ub}\)</span> to remind us
that it is the cell average and not the cell-center.  This distinction
is important when we consider the 4th order method.</p>
<p>In Castro, there are two parameters that together determine the number
and location of the temporal nodes, the accuracy of the integral, and
hence the overall accuracy in time: <code class="docutils literal notranslate"><span class="pre">castro.sdc_order</span></code> and
<code class="docutils literal notranslate"><span class="pre">castro.sdc_quadrature</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">castro.sdc_quadrature</span> <span class="pre">=</span> <span class="pre">0</span></code> uses
Gauss-Lobatto integration, which includes both the starting and ending
time in the time nodes.  This gives us the trapezoid rule for 2nd
order methods and Simpson’s rule for 4th order methods.  Choosing
<code class="docutils literal notranslate"><span class="pre">castro.sdc_quadrature</span> <span class="pre">=</span> <span class="pre">1</span></code> uses Radau IIA integration, which includes
the ending time but not the starting time in the quadrature.</p>
<table class="docutils align-center" id="id11">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">SDC quadrature summary</span><a class="headerlink" href="#id11" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">sdc_order</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">quadrature</span></code></p></th>
<th class="head"><p># of
time nodes</p></th>
<th class="head"><p>temporal
accuracy</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>0</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td><p>trapezoid rule</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>1</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>Simpson’s rule</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>0</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>Radau 2nd order</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>1</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>Radau 4th order</p></td>
</tr>
</tbody>
</table>
<p>The overall evolution appears as:</p>
<ol class="arabic" id="index-5">
<li><p><em>Initialization</em> (<code class="docutils literal notranslate"><span class="pre">initialize_advance</span></code>)</p>
<p>We first do a <code class="docutils literal notranslate"><span class="pre">clean_state</span></code> on the old data (<code class="docutils literal notranslate"><span class="pre">S_old</span></code>).</p>
<p>We next create the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s that store the needed information
at the different time nodes.  Each of the quantities below is a
vector of size <code class="docutils literal notranslate"><span class="pre">SDC_NODES</span></code>, whose components are the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code>
for that time node:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">k_new</span></code> : the current solution at this time node.</p>
<p>Note that
<code class="docutils literal notranslate"><span class="pre">k_new[0]</span></code> is aliased to <code class="docutils literal notranslate"><span class="pre">S_old</span></code>, the solution at the start
of the step, since this never changes (so long as the 0th time
node is the start of the timestep).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_old</span></code> : the advective term at each time node at the old
iteration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A_new</span></code> : the advective term at each time node at the current
iteration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R_old</span></code> : the reactive source term at each time node at the old
iteration.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><em>Advancement</em></p>
<p>Our iteration loop calls <code class="docutils literal notranslate"><span class="pre">do_advance_sdc</span></code> to update the solution through
all the time nodes for a single iteration.</p>
<p>The total number of iterations is <code class="docutils literal notranslate"><span class="pre">castro.sdc_order</span></code> + <code class="docutils literal notranslate"><span class="pre">castro.sdc_extra</span></code>.</p>
</li>
<li><p><em>Finalize</em></p>
<p>This clears the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s we allocated.</p>
</li>
</ol>
<section id="sdc-single-iteration-flowchart">
<h3>SDC Single Iteration Flowchart<a class="headerlink" href="#sdc-single-iteration-flowchart" title="Link to this heading"></a></h3>
<p id="index-6">Throughout this driver we use the <code class="docutils literal notranslate"><span class="pre">State_Type</span></code> <code class="docutils literal notranslate"><span class="pre">StateData</span></code> as
storage for the current node.  In particular, we use the new time slot
in the <code class="docutils literal notranslate"><span class="pre">StateData</span></code> (which we refer to as <code class="docutils literal notranslate"><span class="pre">S_new</span></code>) to allow us to
do <code class="docutils literal notranslate"><span class="pre">FillPatch</span></code> operations.</p>
<p>The update through all time nodes for a single iteration is done by
<code class="docutils literal notranslate"><span class="pre">do_advance_sdc</span></code>.  The basic update appears as:</p>
<ol class="arabic">
<li><p><em>Initialize</em></p>
<p>We allocate <code class="docutils literal notranslate"><span class="pre">Sborder</span></code>.  Just like with the Strang CTU driver, we
will use this as input into the hydrodynamics routines.</p>
</li>
<li><p>Loop over time nodes</p>
<p>We’ll use <code class="docutils literal notranslate"><span class="pre">m</span></code> to denote the current time node and <code class="docutils literal notranslate"><span class="pre">sdc_iter</span></code> to
denote the current (0-based) iteration.  In our loop over time
nodes, we do the following for each node:</p>
<ul>
<li><p>Load in the starting data</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">S_new</span></code> <span class="math notranslate nohighlight">\(\leftarrow\)</span> <code class="docutils literal notranslate"><span class="pre">k_new[m]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clean_state</span></code> on <code class="docutils literal notranslate"><span class="pre">S_new</span></code></p></li>
<li><p>Fill <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> using <code class="docutils literal notranslate"><span class="pre">S_new</span></code></p></li>
</ul>
</li>
<li><p>Construct the hydro sources and advective term</p>
<p>Note: we only do this on the first time node for <code class="docutils literal notranslate"><span class="pre">sdc_iter</span></code> = 0, and
we don’t need to do this for the last time node on the last
iteration.</p>
<ul class="simple">
<li><p>Call <code class="docutils literal notranslate"><span class="pre">do_old_sources</span></code> filling the <code class="docutils literal notranslate"><span class="pre">Source_Type</span></code>
<code class="docutils literal notranslate"><span class="pre">StateData</span></code>, <code class="docutils literal notranslate"><span class="pre">old_source</span></code>.</p></li>
<li><p>Convert the sources to 4th order averages if needed.</p></li>
<li><p>Convert the conserved variables to primitive variables</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">construct_mol_hydro_source</span></code> to get the advective update
at the current time node, stored in <code class="docutils literal notranslate"><span class="pre">A_new[m]</span></code>.</p></li>
</ul>
</li>
<li><p>Bootstrap the first iteration.</p>
<p>For the first iteration, we don’t have the old iteration’s
advective and reaction terms needed in the SDC update.  So for
the first time node (<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">0</span></code>) on the first iteration, we do:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A_old[n]</span></code> = <code class="docutils literal notranslate"><span class="pre">A_old[0]</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> loops over all time nodes.</p></li>
<li><p>Compute the reactive source using the <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">0</span></code> node’s state and
store this in <code class="docutils literal notranslate"><span class="pre">R_old[0]</span></code>.</p>
<p>Then fill all other time nodes as: <code class="docutils literal notranslate"><span class="pre">R_old[n]</span></code> = <code class="docutils literal notranslate"><span class="pre">R_old[0]</span></code></p>
</li>
</ul>
</li>
<li><p>Do the SDC update from node <code class="docutils literal notranslate"><span class="pre">m</span></code> to <code class="docutils literal notranslate"><span class="pre">m+1</span></code>.</p>
<p>We call <code class="docutils literal notranslate"><span class="pre">do_sdc_update()</span></code> to do the update in time to the next
node.  This solves the nonlinear system (when we have reactions)
and stores the solution in <code class="docutils literal notranslate"><span class="pre">k_new[m+1]</span></code>.</p>
</li>
</ul>
</li>
<li><p>Store the advective terms for the next iteration.</p>
<p>Since we are done with this iteration, we do: <code class="docutils literal notranslate"><span class="pre">A_old[n]</span></code>
<span class="math notranslate nohighlight">\(\leftarrow\)</span> <code class="docutils literal notranslate"><span class="pre">A_new[n]</span></code>.</p>
</li>
<li><p>Store <code class="docutils literal notranslate"><span class="pre">R_old</span></code> for the next iteration.  We do this by
calling the reaction source one last time using the data for each
time node.</p></li>
<li><p>Store the new-time solution.</p>
<p>On the last iteration, we save the solution to the <code class="docutils literal notranslate"><span class="pre">State_Type</span></code> <code class="docutils literal notranslate"><span class="pre">StateData</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">S_new</span></code> <span class="math notranslate nohighlight">\(\leftarrow\)</span> <code class="docutils literal notranslate"><span class="pre">k_new[SDC_NODES-1]</span></code></p>
</li>
<li><p>Store the old and new sources in the State Data.</p></li>
<li><p>Store the reaction information for the plotfiles.</p></li>
<li><p>Call <code class="docutils literal notranslate"><span class="pre">finalize_do_advance</span></code> to clean up the memory.</p></li>
</ol>
</section>
</section>
<section id="simplified-sdc-evolution">
<h2>Simplified-SDC Evolution<a class="headerlink" href="#simplified-sdc-evolution" title="Link to this heading"></a></h2>
<p>The simplified SDC method uses the CTU advection solver together with
an ODE solution to update the compute advective-reacting system.  This
is selected by <code class="docutils literal notranslate"><span class="pre">castro.time_integration_method</span> <span class="pre">=</span> <span class="pre">3</span></code>.</p>
<p>We use one additional StateData type here, <code class="docutils literal notranslate"><span class="pre">Simplified_SDC_React_Type</span></code>,
which will hold the reactive source needed by hydrodynamics.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code must be compiled with <code class="docutils literal notranslate"><span class="pre">USE_SIMPLIFIED_SDC</span> <span class="pre">=</span> <span class="pre">TRUE</span></code> to use this
evolution type.</p>
</div>
<p>We express our system as:</p>
<div class="math notranslate nohighlight">
\[\Ub_t = \mathcal{A}(\Ub) + \Rb(\Ub)\]</div>
<p>here <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is the advective source, which includes both the
flux divergence and the hydrodynamic source terms (e.g. gravity):</p>
<div class="math notranslate nohighlight">
\[\mathcal{A}(\Ub) = -\nabla \cdot \Fb(\Ub) + \Sb\]</div>
<p>The simplified-SDC version of the main advance loop looks similar to the Strang CTU
version, but includes an iteration loop over the hydro, gravity, and
reaction update. So the only difference happens in step 2 of the
flowchart outlined in § <a class="reference external" href="#flow:sec:nosdc">2</a>. In particular this
step now proceeds as a loop over <code class="docutils literal notranslate"><span class="pre">do_advance_ctu</span></code>.  The differences
with the Strang CTU version are highlighted below.</p>
<p>Note that the
radiation implicit update is not done as part of the Simplified-SDC iterations.</p>
<section id="simplified-sdc-hydro-advance">
<h3>Simplified_SDC Hydro Advance<a class="headerlink" href="#simplified-sdc-hydro-advance" title="Link to this heading"></a></h3>
<p>The evolution in <code class="docutils literal notranslate"><span class="pre">do_advance</span></code> is substantially different than the
Strang case. In particular, reactions are not evolved. Here we
summarize those differences.</p>
<ol class="arabic">
<li><p><em>Initialize</em> [<code class="docutils literal notranslate"><span class="pre">initialize_do_advance()</span></code>]</p>
<p>This is unchanged from the initialization in the CTU Strang algorithm.</p>
</li>
<li><p><em>Construct time-level n sources and apply</em>
[<code class="docutils literal notranslate"><span class="pre">construct_old_gravity()</span></code>, <code class="docutils literal notranslate"><span class="pre">do_old_sources()</span></code>]</p>
<p>Unlike the Strang case, there is no need to extrapolate source
terms to the half-time for the prediction (the
<code class="docutils literal notranslate"><span class="pre">castro.source_term_predictor</span></code> parameter), since the
Simplified-SDC provides a natural way to approximate the
time-centered source—we simply use the iteratively-lagged new-time
source.  We add the corrector from the previous iteration to the
source Multifabs before adding the current source.  The corrector
(stored in <code class="docutils literal notranslate"><span class="pre">source_corrector</span></code>) has the form:</p>
<div class="math notranslate nohighlight">
\[\Sb^\mathrm{corr} = \frac{1}{2} \left ( \Sb^{n+1,(k-1)} - S^n \right )\]</div>
<p>where <span class="math notranslate nohighlight">\(\Sb^n\)</span> does not have an iteration subscript, since we always have the
same old time state.</p>
<p>Applying this corrector to the the source at time <span class="math notranslate nohighlight">\(n\)</span>, will give
us a source that is time-centered,</p>
<div class="math notranslate nohighlight">
\[{\bf S}(\Ub)^{n+1/2} = \frac{1}{2} \left ( {\bf S}(\Ub)^n + {\bf S}(\Ub)^{n+1,(k-1)} \right )\]</div>
<p>For constructing the time-level <span class="math notranslate nohighlight">\(n\)</span> source, there are no
differences compared to the Strang algorithm.</p>
</li>
<li><p><em>Construct the hydro update</em> [<code class="docutils literal notranslate"><span class="pre">construct_hydro_source()</span></code>]</p>
<p>In predicting the interface states, we use an iteratively-lagged
approximation to the reaction source on the primitive variables,
<span class="math notranslate nohighlight">\(\mathcal{I}_q^{k-1}\)</span>.  This addition is done in
<code class="docutils literal notranslate"><span class="pre">construct_ctu_hydro_source()</span></code> after the source terms are
converted to primitive variables.</p>
<p>The result of this is an approximation to <span class="math notranslate nohighlight">\(- [\nabla \cdot {\bf F}]^{n+1/2}\)</span> (not yet the full <span class="math notranslate nohighlight">\(\mathcal{A}(\Ub)\)</span>)
stored in <code class="docutils literal notranslate"><span class="pre">hydro_sources</span></code>.</p>
</li>
<li><p><em>Clean State</em> [<code class="docutils literal notranslate"><span class="pre">clean_state()</span></code>]</p></li>
<li><p><em>Update radial data and center of mass for monopole gravity</em></p></li>
<li><p><em>Correct the source terms with the n+1 contribution</em>
[<code class="docutils literal notranslate"><span class="pre">construct_new_gravity()</span></code>, <code class="docutils literal notranslate"><span class="pre">do_new_sources()</span></code> ]</p></li>
<li><p><em>React</em> <span class="math notranslate nohighlight">\(\Delta t\)</span> [<code class="docutils literal notranslate"><span class="pre">react_state()</span></code>]</p>
<p>We first compute <span class="math notranslate nohighlight">\(\mathcal{A}(\Ub)\)</span> using <code class="docutils literal notranslate"><span class="pre">hydro_sources</span></code>,
<code class="docutils literal notranslate"><span class="pre">old_source</span></code>, and <code class="docutils literal notranslate"><span class="pre">new_source</span></code> via the <code class="docutils literal notranslate"><span class="pre">sum_of_source()</span></code>
function.  This produces an advective source of the form:</p>
<div class="math notranslate nohighlight">
\[\left [ \mathcal{A}(\Ub) \right ]^{n+1/2} = - [\nabla \cdot {\bf F}]^{n+1/2} + \frac{1}{2} (S^n + S^{n+1})\]</div>
<p>We burn for the full <span class="math notranslate nohighlight">\(\Delta t\)</span> including the advective
update as a source, integrating</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{d\Ub}{dt} = \left [ \mathcal{A}(\Ub) \right ]^{n+1/2} + \Rb(\Ub)\]</div>
</div></blockquote>
<p>The result of evolving this equation is stored in <code class="docutils literal notranslate"><span class="pre">S_new</span></code>.</p>
<p>Note, if we do not actually burn in a zone (because we don’t meet
the thermodynamic threshold) then this step does nothing, and the
state updated just via hydrodynamics in <code class="docutils literal notranslate"><span class="pre">S_new</span></code> is kept.</p>
</li>
<li><p><em>Clean state</em>: This ensures that the thermodynamic state is
valid and consistent.</p></li>
<li><p><em>Construct reaction source terms</em>: Construct the change
in the primitive variables due only to reactions over the
timestep, <span class="math notranslate nohighlight">\(\mathcal{I}_q^{k}\)</span>. This will be used in the next
iteration.</p></li>
<li><p><em>Finalize</em> [<code class="docutils literal notranslate"><span class="pre">finalize_do_advance()</span></code>]</p>
<p>This differs from Strang finalization in that we do not construct
<span class="math notranslate nohighlight">\(d\Sb/dt\)</span>, but instead store the total hydrodynamical source
term at the new time. As discussed above, this will be used in the
next iteration to approximate the time-centered source term.</p>
</li>
</ol>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">1</a><span class="fn-bracket">]</span></span>
<p>The correction for gravity is slightly different since we directly compute the time-centered gravitational source term using the hydrodynamic fluxes.</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mpi_plus_x.html" class="btn btn-neutral float-left" title="Running Options: CPUs and GPUs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="software.html" class="btn btn-neutral float-right" title="Software Design" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2024, Castro development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  


</body>
</html>