

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Adaptive Mesh Refinement &mdash; Castro  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css?v=2e394b92" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=fd6eb6e6"></script>
      <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="_static/copybutton.js?v=eaa7b67c"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "macros": {"kth": "{{k_\\mathrm{th}}}", "gcc": "{\\mathrm{g~cm^{-3}}}", "cms": "{\\mathrm{cm~s^{-1}}}", "presunit": "{\\mathrm{dyn~cm^{-2}}}", "accelunit": "{\\mathrm{cm~s^{-2}}}", "ergg": "{\\mathrm{erg~g^{-1}}}", "Ab": "{{\\bf A}}", "eb": "{{\\bf e}}", "Fb": "{{\\bf F}}", "gb": "{{\\bf g}}", "Hb": "{{\\bf H}}", "ib": "{{\\bf i}}", "Ib": "{{\\bf I}}", "Kb": "{{\\bf K}}", "lb": "{{\\bf l}}", "Lb": "{{\\bf L}}", "nb": "{{\\bf n}}", "Pb": "{{\\bf P}}", "Qb": "{{\\bf Q}}", "rb": "{{\\bf r}}", "Rb": "{{\\bf R}}", "Sb": "{{\\bf S}}", "ub": "{{\\bf u}}", "Ub": "{{\\bf U}}", "xb": "{{\\bf x}}", "dt": "{\\Delta t}", "omegadot": "{\\dot\\omega}", "inp": "{{\\rm in}}", "outp": "{{\\rm out}}", "sync": "{{\\rm sync}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\half}", "nph": "{{n+\\myhalf}}", "kpp": "{\\ensuremath{\\kappa_{\\mathrm{P}}}}", "kpr": "{\\ensuremath{\\kappa_{\\mathrm{R}}}}", "kpf": "{\\ensuremath{\\kappa_{\\mathrm{F}}}}", "vb": "{\\boldsymbol{v}}", "vbt": "{\\widetilde{\\vb}}", "rbt": "{\\widetilde{\\rb}}", "ob": "{\\boldsymbol{\\omega}}", "nablab": "{\\boldsymbol{\\nabla}}", "avg": ["{{\\left \\langle #1 \\right \\rangle}}", 1]}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Checkpoint Embiggener" href="ConvertCheckpoint.html" />
    <link rel="prev" title="Spectral Deferred Corrections" href="sdc.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


          
          
          <a href="index.html" class="icon icon-home">
            Castro
              <img src="_static/castro_logo_hot_200.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
    <div class="branch">
        Branch: <a href="../AMR.html">main</a> | <a href="./AMR.html">development</a>
    </div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Castro basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction to Castro</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputs.html">Input Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpi_plus_x.html">Running Options: CPUs and GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="FlowChart.html">Flowchart</a></li>
<li class="toctree-l1"><a class="reference internal" href="software.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu.html">GPU Programming Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="problem_setups.html">Distributed Problem Setups</a></li>
<li class="toctree-l1"><a class="reference internal" href="timestepping.html">Timestepping and Retries</a></li>
<li class="toctree-l1"><a class="reference internal" href="creating_a_problem.html">Setting Up Your Own Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Outputting</a></li>
<li class="toctree-l1"><a class="reference internal" href="regridding.html">Regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Performance Tips</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Castro reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="build_system.html">Build System Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hydrodynamics.html">Hydrodynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="hse.html">Hydrostatic Equilibrium</a></li>
<li class="toctree-l1"><a class="reference internal" href="EOS.html">Equation of State</a></li>
<li class="toctree-l1"><a class="reference internal" href="reactions.html">Reactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="mhd.html">MHD</a></li>
<li class="toctree-l1"><a class="reference internal" href="gravity.html">Gravity</a></li>
<li class="toctree-l1"><a class="reference internal" href="diffusion.html">Thermal Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotation.html">Rotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="sponge.html">Sponge</a></li>
<li class="toctree-l1"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Adaptive Mesh Refinement</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tagging-for-refinement">Tagging for Refinement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronization-algorithm">Synchronization Algorithm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#synchronization-methodology">Synchronization Methodology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#source-terms">Source Terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronization-timing">Synchronization Timing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ConvertCheckpoint.html">Checkpoint Embiggener</a></li>
<li class="toctree-l1"><a class="reference internal" href="self_consistent_field.html">Self-Consistent Field Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="MAESTRO_restart.html">Restarting from Maestro</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development Best Practices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="filelist.html">File list</a></li>
<li class="toctree-l1"><a class="reference internal" href="classlist.html">Class list</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Castro</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Adaptive Mesh Refinement</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/AMR.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="adaptive-mesh-refinement">
<span id="ch-amr"></span><h1>Adaptive Mesh Refinement<a class="headerlink" href="#adaptive-mesh-refinement" title="Link to this heading"></a></h1>
<p>Our approach to adaptive refinement in Castro uses a nested hierarchy
of logically-rectangular grids with simultaneous refinement of the
grids in both space and time. The integration algorithm on the grid
hierarchy is a recursive procedure in which coarse grids are advanced
in time, fine grids are advanced multiple steps to reach the same time
as the coarse grids and the data at different levels are then
synchronized.</p>
<p>During the regridding step, increasingly finer grids
are recursively embedded in coarse grids until the solution is
sufficiently resolved. An error estimation procedure based on
user-specified criteria (described in Section <a class="reference external" href="#sec:tagging">1</a>)
evaluates where additional refinement is needed
and grid generation procedures dynamically create or
remove rectangular fine grid patches as resolution requirements change.</p>
<section id="tagging-for-refinement">
<span id="sec-tagging"></span><h2>Tagging for Refinement<a class="headerlink" href="#tagging-for-refinement" title="Link to this heading"></a></h2>
<p>Castro determines what zones should be tagged for refinement at the
next regridding step by using a set of built-in routines that test on
quantities such as the density and pressure and determining whether
the quantities themselves or their gradients pass a user-specified
threshold. This may then be extended if <code class="docutils literal notranslate"><span class="pre">amr.n_error_buf</span></code> <span class="math notranslate nohighlight">\(&gt; 0\)</span>
to a certain number of zones beyond these tagged zones. This section
describes the process by which zones are tagged, and describes how to
add customized tagging criteria.</p>
<p>We also provide a mechanism for defining a limited set of refinement
schemes from the inputs file; for example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">amr</span><span class="o">.</span><span class="n">refinement_indicators</span> <span class="o">=</span> <span class="n">dens</span> <span class="n">temp</span>

<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">dens</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">dens</span><span class="o">.</span><span class="n">value_greater</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">dens</span><span class="o">.</span><span class="n">field_name</span> <span class="o">=</span> <span class="n">density</span>

<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">temp</span><span class="o">.</span><span class="n">max_level</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">temp</span><span class="o">.</span><span class="n">value_less</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">temp</span><span class="o">.</span><span class="n">field_name</span> <span class="o">=</span> <span class="n">Temp</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">amr.refinement_indicators</span></code> is a list of user-defined names for refinement
schemes. For each defined name, <code class="docutils literal notranslate"><span class="pre">amr.refine.&lt;name&gt;</span></code> accepts predefined fields
describing when to tag. These are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_level</span></code> : maximum level to refine to</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start_time</span></code> : when to start tagging</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end_time</span></code> : when to stop tagging</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_greater</span></code> : value above which we refine</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_less</span></code> : value below which to refine</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gradient</span></code> : absolute value of the difference between adjacent cells above which we refine</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">relative_gradient</span></code> : relative value of the difference between adjacent cells above which we refine</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">field_name</span></code> : name of the string defining the field in the code</p></li>
</ul>
<p>If a refinement indicator is added, either
<code class="docutils literal notranslate"><span class="pre">value_greater</span></code>, <code class="docutils literal notranslate"><span class="pre">value_less</span></code>, <code class="docutils literal notranslate"><span class="pre">gradient</span></code> or <code class="docutils literal notranslate"><span class="pre">relative_gradient</span></code> must be provided.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zones adjacent to a physical boundary cannot be tagged for refinement when
using the Poisson gravity solver. If your tagging criteria are met in these
zones, they will be ignored.</p>
</div>
<p>Sometimes, we wish to force the code to derefine based on a criteria,
even if other indicators tagged a zone for refinement.  This is
accomplished by created another refinement indicator and setting the
<code class="docutils literal notranslate"><span class="pre">derefine</span></code> field to <code class="docutils literal notranslate"><span class="pre">1</span></code>.  For example, to derefine any zone where
the density is less than <code class="docutils literal notranslate"><span class="pre">1.e4</span></code>, we could do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">dencutoff</span><span class="o">.</span><span class="n">derefine</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">dencutoff</span><span class="o">.</span><span class="n">field_name</span> <span class="o">=</span> <span class="n">density</span>
<span class="n">amr</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">dencutoff</span><span class="o">.</span><span class="n">value_less</span> <span class="o">=</span> <span class="mf">1.e4</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">dencutoff</span></code> is lised under <code class="docutils literal notranslate"><span class="pre">amr.refinement_indicators</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any derefinement indicators should appear after those that tag for
refinement in the <code class="docutils literal notranslate"><span class="pre">amr.refinement_indicators</span></code> list, so it is
applied after all the refinement tagging is done.</p>
</div>
<p id="index-0">We provide also the ability for the user to define their own tagging criteria.
This is done through the C++ function <code class="docutils literal notranslate"><span class="pre">problem_tagging</span></code>
in the file <code class="docutils literal notranslate"><span class="pre">problem_tagging.H</span></code>. This function is provided the entire
state (including density, temperature, velocity, etc.) and the array
of tagging status for every zone.</p>
</section>
<section id="synchronization-algorithm">
<span id="sec-amr-synchronization"></span><h2>Synchronization Algorithm<a class="headerlink" href="#synchronization-algorithm" title="Link to this heading"></a></h2>
<p>Here we present the AMR algorithm for the compressible equations with
self-gravity. The gravity component of the algorithm is closely
related to (but not identical to) that in Miniati and Colella, JCP,
2007. The content here is largely based on the content in the original
Castro paper (<span id="id1">[<a class="reference internal" href="zreferences.html#id4" title="A. S. Almgren, V. E. Beckner, J. B. Bell, M. S. Day, L. H. Howell, C. C. Joggerst, M. J. Lijewski, A. Nonaka, M. Singer, and M. Zingale. CASTRO: A New Compressible Astrophysical Solver. I. Hydrodynamics and Self-gravity. ApJ, 715:1221-1238, June 2010. doi:10.1088/0004-637X/715/2/1221.">20</a>]</span>). The most significant difference is the
addition of a different strategy for when to employ the synchronization;
but regardless of whether the original or new strategy is used, the fundamental
synchronization step is identical.</p>
<section id="synchronization-methodology">
<span id="sec-synchronization-methodology"></span><h3>Synchronization Methodology<a class="headerlink" href="#synchronization-methodology" title="Link to this heading"></a></h3>
<p>Over a coarse grid time step we collect flux register information for
the hyperbolic part of the synchronization:</p>
<div class="math notranslate nohighlight">
\[\delta\Fb = -\Delta t_c A^c F^c + \sum \Delta t_f A^f F^f\]</div>
<p>Analogously, at the end of a coarse grid time step we store the
mismatch in normal gradients of <span class="math notranslate nohighlight">\(\phi\)</span> at the coarse-fine interface:</p>
<div class="math notranslate nohighlight">
\[\delta F_\phi =  - A^c \frac{\partial \phi^c}{\partial n}
+ \sum A^f \frac{\partial \phi^f}{\partial n}\]</div>
<p>We want the composite <span class="math notranslate nohighlight">\(\phi^{c-f}\)</span> to satisfy the multilevel
version of (<a class="reference internal" href="gravity.html#equation-eq-self-gravity">(4)</a>) at the synchronization time, just
as we want the coarse and fine fluxes at that time to match. So the goal
is to synchronize <span class="math notranslate nohighlight">\(\phi\)</span> across levels at that time and then zero out
this mismatch register.</p>
<p>At the end of a coarse grid time step we can define
<span class="math notranslate nohighlight">\({\overline{\Ub}}^{c-f}\)</span> and <span class="math notranslate nohighlight">\(\overline{\phi}^{c-f}\)</span> as the composite
of the data from coarse and fine grids as a provisional solution at
time <span class="math notranslate nohighlight">\(n+1\)</span>. (Assume <span class="math notranslate nohighlight">\(\overline{\Ub}\)</span> has been averaged down so that
the data on coarse cells underlying fine cells is the average of the
fine cell data above it.)</p>
<p>The synchronization consists of two parts:</p>
<ul id="index-1">
<li><p>Step 1: Hyperbolic reflux</p>
<p>In the hyperbolic reflux step, we update the conserved variables with
the flux synchronization and adjust the gravitational terms to reflect
the changes in <span class="math notranslate nohighlight">\(\rho\)</span> and <span class="math notranslate nohighlight">\(\ub\)</span>.</p>
<div class="math notranslate nohighlight">
\[{\Ub}^{c, \star} = \overline{\Ub}^{c} + \frac{\delta\Fb}{V},\]</div>
<p>where <span class="math notranslate nohighlight">\(V\)</span> is the volume of the cell and the correction from
<span class="math notranslate nohighlight">\(\delta\Fb\)</span> is supported only on coarse cells adjacent to fine grids.</p>
<p>Note: this can be enabled/disabled via <code class="docutils literal notranslate"><span class="pre">castro.do_reflux</span></code>. Generally,
it should be enabled (1).</p>
<p>Also note that for axisymmetric or 1D spherical coordinates, the
reflux of the pressure gradient is different, since it cannot be
expressed as a divergence in those geometries. We use a separate
flux register in the hydro code to store the pressure term in these
cases.</p>
</li>
<li><p>Step 2: Gravitational synchronization</p>
<p>In this step we correct for the mismatch in normal derivative in
<span class="math notranslate nohighlight">\(\phi^{c-f}\)</span> at the coarse-fine interface, as well as accounting for
the changes in source terms for <span class="math notranslate nohighlight">\((\rho \ub)\)</span> and <span class="math notranslate nohighlight">\((\rho E)\)</span> due to the
change in <span class="math notranslate nohighlight">\(\rho.\)</span></p>
<p>On the coarse grid only, we define</p>
<div class="math notranslate nohighlight">
\[(\delta \rho)^{c} =  \rho^{c, \star} - {\overline{\rho}}^{c}  .\]</div>
<p>We then form the composite residual, which is composed of two
contributions. The first is the degree to which the current <span class="math notranslate nohighlight">\(\overline{\phi}^{c-f}\)</span> does not satisfy the original equation on a
composite grid (since we have solved for <span class="math notranslate nohighlight">\(\overline{\phi}^{c-f}\)</span>
separately on the coarse and fine levels). The second is the response
of <span class="math notranslate nohighlight">\(\phi\)</span> to the change in <span class="math notranslate nohighlight">\(\rho.\)</span> We define</p>
<div class="math notranslate nohighlight">
\[R \equiv  4 \pi G \rho^{\star,c-f} - \Delta^{c-f} \; \overline{\phi}^{c-f}
= - 4 \pi G (\delta \rho)^c - (\nabla \cdot \delta F_\phi ) |_c   .\]</div>
<p>Then we solve</p>
<div class="math notranslate nohighlight">
\[\Delta^{c-f} \; \delta \phi^{c-f} = R
\label{eq:gravsync}\]</div>
<p>as a two level solve at the coarse and fine levels.
We define the update to gravity,</p>
<div class="math notranslate nohighlight">
\[\delta {\bf g}^{c-f} = \nabla (\delta \phi^{c-f})  .\]</div>
<p>Finally, we need to</p>
<ul>
<li><p>add <span class="math notranslate nohighlight">\(\delta \phi^{c-f}\)</span> directly to
to <span class="math notranslate nohighlight">\(\phi^{c}\)</span> and <span class="math notranslate nohighlight">\(\phi^{f}\)</span> and interpolate <span class="math notranslate nohighlight">\(\delta \phi^{c-f}\)</span> to any finer
levels and add to the current <span class="math notranslate nohighlight">\(\phi\)</span> at those levels.</p></li>
<li><p>if level <span class="math notranslate nohighlight">\(c\)</span> is not the coarsest level in the calculation, then we must transmit the
effect of this change in <span class="math notranslate nohighlight">\(\phi\)</span> to the coarser levels by updating the flux register between
level <span class="math notranslate nohighlight">\(c\)</span> and the next coarser level, <span class="math notranslate nohighlight">\(cc.\)</span> In particular, we set</p>
<div class="math notranslate nohighlight">
\[\delta {F_\phi}^{cc-c} = \delta F_\phi^{cc-c}
+ \sum A^c \frac{\partial (\delta \phi)^{c-f}}{\partial n}  .\]</div>
</li>
</ul>
<p>The gravity synchronization algorithm can be disabled with
gravity.no_sync = 1. This should be done with care. Generally,
it is okay only if he refluxing happens in regions of low density that
don’t affect the gravity substantially.</p>
</li>
</ul>
</section>
<section id="source-terms">
<span id="sec-synchronization-sources"></span><h3>Source Terms<a class="headerlink" href="#source-terms" title="Link to this heading"></a></h3>
<p>After a synchronization has been applied, the state on the coarse grid
has changed, due to the change in fluxes at the coarse-fine boundary as
well as the change in the gravitational field. This poses a problem
regarding the source terms, all of which generally rely either on the
state itself, or on the global variables affected by the synchronization
such as the gravitational field. The new-time sources constructed on the
coarse grid all depended on what the state was after the coarse-grid
hydrodynamic update, but the synchronization and associated flux
correction step retroactively changed that hydrodynamic update. So one
can imagine that in a perfect world, we would have calculated the
hydrodynamic update first, including the coarse-fine mismatch
corrections, and only then computed the source terms at the new time.
Indeed, an algorithm that did not subcycle, but marched every zone along
at the same timestep, could do so – and some codes, like FLASH,
actually do this, where no new-time source terms are computed on any
level until the hydrodynamic update has been fully completed and the
coarse-fine mismatches corrected. But in Castro we cannot do this; in
general we assume the ability to subcycle, so the architecture is set up
to always calculate the new-time source terms on a given level
immediately after the hydrodynamic update on that level. Hence on the
coarse level we calculate the new-time source terms before any fine grid
timesteps occur.</p>
<p>One way to fix this, as suggested by Miniati and Colella for the case
of gravity, is to explicitly compute what the difference in the source
term is as a result of any flux corrections across coarse-fine
boundaries. They work out the form of this update for the case of a
cell-centered gravitational force, which has contributions from both
the density advected across the coarse-fine interfaces
(i.e. <span class="math notranslate nohighlight">\(\delta \rho \mathbf{g}\)</span>, where <span class="math notranslate nohighlight">\(\delta \rho\)</span> is the density
change due to the coarse-fine synchronization on the coarse rid), as
well as the global change in the gravitational field due to the
collective mass motion (see Miniati and Colella for the explicit form
of the source term). This has a couple of severe limitations. First,
it means that when the form of the source term is changed, the form of
the corrector term is changed too. For example, it is less easy to
write down the form of this corrector term for the flux-based
gravitational energy source term that is now standard in Castro.
Second, gravity is a relatively easy case due to its linearity in the
density and the gravitational acceleration; other source terms
representing more complicated physics might not have an easily
expressible representation in terms of the reflux contribution. For
example, for a general nuclear reaction network (that does not have an
analytic solution), it is not possible to write down an analytic
expression for the nuclear reactions that occur because of
<span class="math notranslate nohighlight">\(\delta \rho\)</span>.</p>
<p>Instead we choose a more general approach. On the coarse level, we save
the new-time source terms that were applied until the end of the fine
timesteps. We also save the fine level new-time source terms. Then, when
we do the AMR synchronization after a fine timestep, we first subtract
the previously applied new-time source terms to both the coarse and the
fine level, then do the flux correction and associated gravitational
sync solve, and then re-compute the new-time source terms on both the
coarse and the fine level <a class="footnote-reference brackets" href="#id5" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. In this way, we get almost
the ideal behavior – if we aren’t subcycling, then we get essentially
the same state at the end of the fine timestep as we would in a code
that explicitly had no subcycling. The cost is re-computing the new-time
source terms that second time on each level. For most common source
terms such as gravity, this is not a serious problem – the cost of
re-computing <span class="math notranslate nohighlight">\(\rho \mathbf{g}\)</span> (for example, once you already know
<span class="math notranslate nohighlight">\(\mathbf{g}\)</span>) is negligible compared to the cost of actually computing
<span class="math notranslate nohighlight">\(\mathbf{g}\)</span> itself (say, for self-gravity). If you believe that the
error in not recomputing the source terms is sufficiently low, or the
computational cost of computing them too high, you can disable this
behavior <a class="footnote-reference brackets" href="#id6" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> using the
code parameter castro.update_sources_after_reflux.</p>
<p>Note that at present nuclear reactions are not enabled as part of this
scheme, and at present are not automatically updated after an AMR
synchronization. This will be amended in a future release of Castro.</p>
</section>
<section id="synchronization-timing">
<span id="sec-synchronization-timing"></span><h3>Synchronization Timing<a class="headerlink" href="#synchronization-timing" title="Link to this heading"></a></h3>
<p>The goal of the synchronization step is for the coarse and fine grid to
match at the end of a coarse timesteps, after all subcycled fine grid
timesteps have been completed and the two levels have reached the same
simulation time. If subcycling is disabled, so that the coarse and fine
grid take the same timestep, then this is sufficient. However, in the
general subcycling case, the situation is more complicated. Consider the
discussion about source terms in <a class="reference external" href="#sec:synchronization_sources">2.2</a>. If
we have a coarse level and one fine level with a refinement ratio of
two, then for normal subcycling the fine grid takes two timesteps for
every one timestep taken by the coarse level. The strategy advocated by
the original Castro paper (and Miniati and Colella) is to only do the
AMR synchronization at the actual synchronization time between coarse
and fine levels, that is, at the end of the second fine timestep.
Consequently, we actually only update the source terms after that second
fine timestep. Thus note that on the fine grid, only the <em>new-time</em>
source terms in the <em>second</em> fine timestep are updated. But a
moment’s thought should reveal a limitation of this. The first fine grid
timestep was also responsible for modifying the fluxes on the coarse
grid, but the algorithm as presented above didn’t take full account of
this information. So, the gravitational field at the old time in
the second fine timestep is actually missing information that would have
been present if we had updated the coarse grid already. Is there a way
to use this information? For the assumptions we make in Castro, the
answer is actually yes. If we apply the effect of the synchronization
not at the synchronization time but at the end of every fine
timestep, then every fine timestep always has the most up-to-date
information possible about the state of the gravitational field. Now, of
course, in fine timesteps before the last one, we have not actually
reached the synchronization time. But we already know at the end of the
first fine timestep what the synchronization correction will be from
that fine timestep: it will be equal to 1/2 of the coarse contribution
to the flux register and the normal contribution to the flux register
for just that timestep. This is true because in Castro, we assume that
the fluxes provided by the hydrodynamic solver are piecewise-constant
over the timestep, which is all that is needed to be second-order
accurate in time if the fluxes are time centered <a class="footnote-reference brackets" href="#id7" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. So it is fair to say
that halfway through the coarse timestep, half of the coarse flux has
been advected, and we can mathematically split the flux register into
two contributions that have equal weighting from the coarse flux. (In
general, of course, the coarse flux contribution at each fine timestep
is weighted by <span class="math notranslate nohighlight">\(1/R\)</span> where <span class="math notranslate nohighlight">\(R\)</span> is the refinement ratio between the
coarse and fine levels.) So, there is nothing preventing us from
updating the coarse solution at the synchronization time <span class="math notranslate nohighlight">\(t^{n+1}_c\)</span>
after this first fine timestep; we already know at that point how the
coarse solution will change, so why not use that information? We can
then update the gravitational potential at <span class="math notranslate nohighlight">\(t^{n+1/2}_c\)</span> that is used to
construct the boundary conditions for the gravitational potential solve
on the fine grid at the beginning of the second fine timestep.</p>
<p>In practice, this just means calling the synchronization routine
described in <a class="reference external" href="#sec:synchronization_methodology">2.1</a>, with the only
modification being that the flux register contribution from the coarse
grid is appropriately weighted by the fine grid timestep instead of
the coarse grid timestep, and we only include the current fine step:</p>
<div class="math notranslate nohighlight">
\[\delta\Fb = -\Delta t_f A^c F^c + \Delta t_f A^f F^f\]</div>
<p>The form of the <span class="math notranslate nohighlight">\(\phi\)</span> flux register remains unchanged, because the
intent of the gravity sync solve is to simply instantaneously correct
the mismatch between the fine and coarse grid. The only difference,
then, between the old strategy and this new method is that we call the
synchronization at the end of every fine timestep instead of only the
last subcycled one, and we change the weighting appropriately. This
new method is more expensive as currently implemented because we have
to do <span class="math notranslate nohighlight">\(R\)</span> gravitational sync solves, refluxes, and source term
recalculations instead of only one. However, it results in maximal
possible accuracy, especially in cases where significant amounts of
material are crossing refinement boundaries. The reflux strategy is
controlled by the parameter castro.reflux_strategy. At present
the old method is still the default.</p>
<p>Note that one does not need to be using self-gravity for this to be
beneficial. Even in pure hydrodynamics this can matter. If a regrid
occurs on the fine level, new zones on the boundaries of the current
fine level are filled by interpolation from the coarse level. In the
old method, that interpolation is not using the most up-to-date data
that accounts for the synchronization.</p>
<p>For multiple levels of refinement, the scheme extends naturally. In
the old method, we always call the synchronization at the
synchronization time between any two levels. So for example with two
jumps in refinement by a factor of two, there is a synchronization at
the end of the first two timesteps on level 2 (between level 1 and
level 2), a synchronization after the next two timesteps on level 2
(again between level 1 and level 2), and then a synchronization
between level 0 and level 1. In the new method, we always call the
synchronization at the end of every timestep <em>on the finest level
only</em>, and we simultaneously do the synchronization <em>on every
level</em>. The timestep <span class="math notranslate nohighlight">\(\Delta t_f\)</span> in the flux register is just the
timestep on the finest level. (If this is unclear, give it a sanity
check: when the sum of all flux register totals is added up, the level
0 contribution will have a factor of <span class="math notranslate nohighlight">\(\Delta t\)</span> equal to the coarse
grid timestep since the sum of the timesteps on the finest level over
the entire advance must equal the level 0 timestep. So, the final
contribution from the flux register is the same as if we had saved up
the flux mismatch until the end of the level 0 timestep.) The
synchronization no longer needs to be called at the end of any coarser
level’s timestep because it will already be up to date as a result of
the synchronizations applied at the end of the fine level timesteps.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>In the absence of a global field like
the gravitational potential, this would only need to be done on the
coarse level, as we always assume that the solution on the fine grid is
correct and average it down to the coarse grid. In Castro we do it by
default on the fine level too in anticipation of the fact that gravity
is a common component of many of our production science
simulations. This could be generalized so that if you aren’t using any
global force fields, you don’t bother updating the fine level. If this
is important to the science you want to do, please let the Castro developers know and we can look into it.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>in general it may be desirable for this to be a
source-term specific setting, so that some source terms that are cheap
or physically important are re-computed after a synchronization can be
set to update, while others can be disabled. If this is important for
your science application, please let the developers know, as this would
be a straightforward extension of the current architecture.</p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>If this scheme
is generalized to higher-order methods, in principle all one would need
to do is integrate the fluxes until <span class="math notranslate nohighlight">\(\Delta t / 2\)</span>, which is what we are
doing here for the constant-in-time flux case.</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sdc.html" class="btn btn-neutral float-left" title="Spectral Deferred Corrections" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ConvertCheckpoint.html" class="btn btn-neutral float-right" title="Checkpoint Embiggener" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2024, Castro development team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  


</body>
</html>