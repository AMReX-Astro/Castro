

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Software Design &mdash; Castro  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"kth": "{{k_\\mathrm{th}}}", "gcc": "{\\mathrm{g~cm^{-3}}}", "cms": "{\\mathrm{cm~s^{-1}}}", "presunit": "{\\mathrm{dyn~cm^{-2}}}", "accelunit": "{\\mathrm{cm~s^{-2}}}", "ergg": "{\\mathrm{erg~g^{-1}}}", "Ab": "{{\\bf A}}", "eb": "{{\\bf e}}", "Fb": "{{\\bf F}}", "gb": "{{\\bf g}}", "Hb": "{{\\bf H}}", "ib": "{{\\bf i}}", "Ib": "{{\\bf I}}", "Kb": "{{\\bf K}}", "lb": "{{\\bf l}}", "Lb": "{{\\bf L}}", "nb": "{{\\bf n}}", "Pb": "{{\\bf P}}", "Qb": "{{\\bf Q}}", "rb": "{{\\bf r}}", "Rb": "{{\\bf R}}", "Sb": "{{\\bf S}}", "ub": "{{\\bf u}}", "Ub": "{{\\bf U}}", "xb": "{{\\bf x}}", "dt": "{\\Delta t}", "omegadot": "{\\dot\\omega}", "inp": "{{\\rm in}}", "outp": "{{\\rm out}}", "sync": "{{\\rm sync}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\half}", "nph": "{{n+\\myhalf}}", "kpp": "{\\ensuremath{\\kappa_{\\mathrm{P}}}}", "kpr": "{\\ensuremath{\\kappa_{\\mathrm{R}}}}", "kpf": "{\\ensuremath{\\kappa_{\\mathrm{F}}}}", "vb": "{\\boldsymbol{v}}", "vbt": "{\\widetilde{\\vb}}", "rbt": "{\\widetilde{\\rb}}", "ob": "{\\boldsymbol{\\omega}}", "nablab": "{\\boldsymbol{\\nabla}}", "avg": ["{{\\left \\langle #1 \\right \\rangle}}", 1]}}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Distributed Problem Setups" href="problem_setups.html" />
    <link rel="prev" title="Flowchart" href="FlowChart.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          


          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Castro
          

          
            
            <img src="_static/castro_logo_hot_200.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
    <div class="branch">
        Branch: <a href="../software.html">main</a> | <a href="./software.html">development</a>
    </div>

        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Castro basics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction to Castro</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputs.html">Input Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpi_plus_x.html">Running Options: CPUs and GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="FlowChart.html">Flowchart</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Software Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#code-structure">Code structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#major-data-structures">Major data structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#amr"><code class="docutils literal notranslate"><span class="pre">Amr</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#amrlevel-and-castro-classes"><code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code> and Castro classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#floating-point-data">Floating point data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#box-and-farraybox"><code class="docutils literal notranslate"><span class="pre">Box</span></code> and <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#multifab"><code class="docutils literal notranslate"><span class="pre">MultiFab</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#statedata"><code class="docutils literal notranslate"><span class="pre">StateData</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#various-source-multifabs">Various source <code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mfiter-and-interacting-with-fortran"><code class="docutils literal notranslate"><span class="pre">MFIter</span></code> and interacting with Fortran</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#non-tiling-mfiter">Non-Tiling MFIter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amrexs-current-tiling-approach-in-c">AMReX’s Current Tiling Approach In C++</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#practical-details-in-working-with-tiling">Practical Details in Working with Tiling</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#boundaries-fillpatch-and-fillpatchiterator">Boundaries: <code class="docutils literal notranslate"><span class="pre">FillPatch</span></code> and <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#physical-boundaries">Physical Boundaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fluxregister"><code class="docutils literal notranslate"><span class="pre">FluxRegister</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#other-amrex-concepts">Other AMReX Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometry-class"><code class="docutils literal notranslate"><span class="pre">Geometry</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parmparse-class"><code class="docutils literal notranslate"><span class="pre">ParmParse</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-estimators">Error Estimators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gravity-class"><code class="docutils literal notranslate"><span class="pre">Gravity</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fortran-helper-modules">Fortran Helper Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#amrex-constants-module"><code class="docutils literal notranslate"><span class="pre">amrex_constants_module</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#extern-probin-module"><code class="docutils literal notranslate"><span class="pre">extern_probin_module</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#fundamental-constants-module"><code class="docutils literal notranslate"><span class="pre">fundamental_constants_module</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#math-module"><code class="docutils literal notranslate"><span class="pre">math_module</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#meth-params-module"><code class="docutils literal notranslate"><span class="pre">meth_params_module</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#model-parser-module"><code class="docutils literal notranslate"><span class="pre">model_parser_module</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#prob-params-module"><code class="docutils literal notranslate"><span class="pre">prob_params_module</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="problem_setups.html">Distributed Problem Setups</a></li>
<li class="toctree-l1"><a class="reference internal" href="timestepping.html">Timestepping and Retries</a></li>
<li class="toctree-l1"><a class="reference internal" href="creating_a_problem.html">Setting Up Your Own Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Outputting</a></li>
<li class="toctree-l1"><a class="reference internal" href="regridding.html">Regridding</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption"><span class="caption-text">Castro reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="build_system.html">Build System Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu_porting.html">Offloading a routine to GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hydrodynamics.html">Hydrodynamics</a></li>
<li class="toctree-l1"><a class="reference internal" href="mhd.html">MHD</a></li>
<li class="toctree-l1"><a class="reference internal" href="gravity.html">Gravity</a></li>
<li class="toctree-l1"><a class="reference internal" href="diffusion.html">Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotation.html">Rotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="sponge.html">Sponge</a></li>
<li class="toctree-l1"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="EOSNetwork.html">Microphysics</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMR.html">Adaptive Mesh Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConvertCheckpoint.html">Checkpoint Embiggener</a></li>
<li class="toctree-l1"><a class="reference internal" href="self_consistent_field.html">Self-Consistent Field Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="MAESTRO_restart.html">Restarting from Maestro</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development Best Practices</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="filelist.html">File list</a></li>
<li class="toctree-l1"><a class="reference internal" href="classlist.html">Class list</a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Castro</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Software Design</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/software.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="software-design">
<h1>Software Design<a class="headerlink" href="#software-design" title="Permalink to this headline">¶</a></h1>
<div class="section" id="code-structure">
<h2>Code structure<a class="headerlink" href="#code-structure" title="Permalink to this headline">¶</a></h2>
<p>Castro is built upon the AMReX C++ framework. This provides
high-level classes for managing an adaptive mesh refinement
simulation, including the core data structures we will deal with. A
key design pattern in AMReX is that the overall memory management
and parallelization is done in the C++ layer, while the heavy
computational work is done in Fortran kernels. AMReX provides
convenient data structures that allow for this workflow—high level
objects in C++ that communicate with Fortran through pointers to
data regions that appear as multidimensional arrays.</p>
<p>Castro uses a structured-grid approach to hydrodynamics. We work
with square/cubic zones that hold state variables (density, momentum,
etc.) and compute the fluxes of these quantities through the
interfaces of the zones (this is a finite-volume approach).
Parallelization is achieved by domain decomposition. We divide our
domain into many smaller boxes, and distributed these across
processors. When information is needed at the boundaries of the
boxes, messages are exchanged and this data is held in a perimeter of
<em>ghost cells</em>. AMReX manages this decompostion and
communication for us. Additionally, AMReX implements adaptive mesh
refinement. In addition to the coarse decomposition of our domain
into zones and boxes, we can refine rectangular regions by adding
finer-gridded boxes on top of the coarser grid. We call the
collection of boxes at the same resolution a <em>level</em>.</p>
<p>Castro uses a hybrid MPI + OpenMP approach to parallelism. MPI is
at used to communicate across nodes on a computer and OpenMP is used
within a node, to loop over subregions of a box with different
threads.</p>
<p>The code structure in the Castro/ directory reflects the
division between C++ and Fortran.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">constants/</span></code>: contains a file of useful constants in CGS units</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">docs/</span></code>: you’re reading this now!</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Exec/</span></code>: various problem implementations, sorted by category:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gravity_tests/</span></code>: test problems that primarily exercise the gravity solver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hydro_tests/</span></code>: test problems of the hydrodynamics (with or without reactions)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radiation_tests/</span></code>: test problems that primarily exercise the radiation hydrodynamics solver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reacting_tests/</span></code>: test problems that primarily exercise the reactions (and hydro + reaction coupling)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scf_tests/</span></code>: problem setups that use the self-consistent field initialization</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">science/</span></code>: problem setups that were used for scientific investigations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unit_tests/</span></code>: test problems that exercise primarily a single module</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">external/Microphysics/</span></code>: contains directories for different default
microphysics (these are all implemented in Fortran)</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">conductivity/</span></code>: the thermal conductivity</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EOS/</span></code>: the equation of state</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">networks/</span></code>: the nuclear reaction networks</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">opacity/</span></code>: the radiative opacity (used with radiation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">viscosity/</span></code>: the viscous transport coefficient</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Source/</span></code>: source code. In this main directory is all of the
code. Sources are mixed C++ and Fortran and are organized by topic
as:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">diffusion/</span></code> : thermal diffusion code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">driver/</span></code> : the main driver, I/O, runtime parameter support</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gravity/</span></code> : self-gravity code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hydro/</span></code> : the compressible hydrodynamics code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">particles/</span></code> : support for particles</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">problems/</span></code> : template code for implementing a problem</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">radiation/</span></code> : the implicit radiation solve code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reactions/</span></code> : nuclear reaction code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rotation/</span></code> : rotating code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scf/</span></code> : the self-consistent field initialization support</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sources/</span></code> : hydrodynamics source terms support</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Util/</span></code>: a catch-all for additional things you may need</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ConvertCheckpoint/</span></code>: a tool to convert a checkpoint file to
a larger domain</p></li>
<li><p>…</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="major-data-structures">
<h2>Major data structures<a class="headerlink" href="#major-data-structures" title="Permalink to this headline">¶</a></h2>
<p>The following data structures are the most commonly encountered when
working in the C++ portions of Castro. This are all
AMReX data-structures / classes.</p>
<div class="section" id="amr">
<h3><code class="docutils literal notranslate"><span class="pre">Amr</span></code><a class="headerlink" href="#amr" title="Permalink to this headline">¶</a></h3>
<p>This is the main class that drives the whole simulation. This is
the highest level in Castro.</p>
</div>
<div class="section" id="amrlevel-and-castro-classes">
<h3><code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code> and Castro classes<a class="headerlink" href="#amrlevel-and-castro-classes" title="Permalink to this headline">¶</a></h3>
<p>An <code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code> is a virtual base class provided by AMReX that
stores all the state data on a single level in the AMR hierarchy and
understands how to advance that data in time.</p>
<p>The most important data managed by the <code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code> is an array of
<code class="docutils literal notranslate"><span class="pre">StateData</span></code>, which holds the fluid quantities, etc., in the boxes
that together make up the level.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Castro</span></code> class is derived from the <code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code>. It provides
the Castro-specific routines to evolve our system of equations. Like
the <code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code>, there is one <code class="docutils literal notranslate"><span class="pre">Castro</span></code> object for each level in the
AMR hierarchry.</p>
<p>A lot of the member data in the <code class="docutils literal notranslate"><span class="pre">Castro</span></code> class are static member
variables—this means that they are shared across all instances of
the class. So, in this case, every level will have the same data.
This is done, in particular, for the values of the runtime parameters,
but also for the <code class="docutils literal notranslate"><span class="pre">Gravity</span></code>, <code class="docutils literal notranslate"><span class="pre">Diffusion</span></code>, and <code class="docutils literal notranslate"><span class="pre">Radiation</span></code>
objects. This means that those objects cover all levels and are the
same object in each instantiation of the <code class="docutils literal notranslate"><span class="pre">Castro</span></code> class.</p>
</div>
<div class="section" id="floating-point-data">
<h3>Floating point data<a class="headerlink" href="#floating-point-data" title="Permalink to this headline">¶</a></h3>
<p>Floating point data in the C++ AMReX framework is declared as
<code class="docutils literal notranslate"><span class="pre">Real</span></code>. This is typedef to either <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">double</span></code> depending
on the make variable <code class="docutils literal notranslate"><span class="pre">PRECISION</span></code>.</p>
<p>The corresponding type for Fortran is provided by the
<code class="docutils literal notranslate"><span class="pre">amrex_fort_module</span></code> as <code class="docutils literal notranslate"><span class="pre">c_real</span></code>. We typically rename
this to rt when using it. An example of a declaration of a
parameter is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">amrex_fort_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">rt</span> <span class="o">=&gt;</span> <span class="n">amrex_real</span>
<span class="n">real</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="p">::</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-10</span><span class="n">_rt</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">amrex_constants_module</span></code> provides common constants that can
be used in the code, like <code class="docutils literal notranslate"><span class="pre">ZERO</span></code>, <code class="docutils literal notranslate"><span class="pre">THIRD</span></code>, <code class="docutils literal notranslate"><span class="pre">ONE</span></code>, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>single precision support in Castro is not yet complete. In
particular, a lot of the supporting microphysics has not been updated.</p>
</div>
</div>
<div class="section" id="box-and-farraybox">
<h3><code class="docutils literal notranslate"><span class="pre">Box</span></code> and <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code><a class="headerlink" href="#box-and-farraybox" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">Box</span></code> is simply a rectangular region in space. It does not hold
data. In AMReX, an AMR level has a global index space, with
<span class="math notranslate nohighlight">\((0,0,0)\)</span> being the lower left corner of the domain at that level, and
<span class="math notranslate nohighlight">\((N_x-1, N_y-1, N_z-1)\)</span> being the upper right corner of the domain
(for a domain of <span class="math notranslate nohighlight">\(N_x \times N_y \times N_z\)</span> zones). The location of
any <code class="docutils literal notranslate"><span class="pre">Box</span></code> at a level can be uniquely specified with respect to this
global index space by giving the index of its lower-left and
upper-right corners. <a class="reference internal" href="#fig-soft-indexspace"><span class="std std-numref">Fig. 1</span></a> shows an
example of three boxes at the same level of refinement.</p>
<p>AMReX provides other data structures that collect Boxes together,
most importantly the <code class="docutils literal notranslate"><span class="pre">BoxArray</span></code>. We generally do not use these
directly, with the exception of the <code class="docutils literal notranslate"><span class="pre">BoxArray</span></code> <code class="docutils literal notranslate"><span class="pre">grids</span></code>,
which is defined as part of the <code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code> class that <code class="docutils literal notranslate"><span class="pre">Castro</span></code>
inherits. <code class="docutils literal notranslate"><span class="pre">grids</span></code> is used when building new <code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code> to give
the layout of the boxes at the current level.</p>
<div class="figure align-default" id="id9">
<span id="fig-soft-indexspace"></span><a class="reference internal image-reference" href="_images/index_grid2.png"><img alt="_images/index_grid2.png" src="_images/index_grid2.png" style="width: 4in;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Three boxes that comprise a single level. At this
resolution, the domain is 20 <span class="math notranslate nohighlight">\(\times\)</span> 18 zones. Note that the
indexing in AMReX starts with <span class="math notranslate nohighlight">\(0\)</span>.</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> or <em>FAB</em>, for <em>Fortran array box</em> is a data
structure that contains a <code class="docutils literal notranslate"><span class="pre">Box</span></code> locating it in space, as well as a
pointer to a data buffer. The real floating point data are stored as
one-dimensional arrays in <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> es. The associated <code class="docutils literal notranslate"><span class="pre">Box</span></code> can be
used to reshape the 1D array into multi-dimensional arrays to be used
by Fortran subroutines. The key part of the C++ AMReX data
structures is that this data buffer can be sent to Fortran, where it
will appear as a DIM+1 dimensional array (DIM space + 1
component).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Castro is complied for a specific dimensionality.</p>
</div>
</div>
<div class="section" id="multifab">
<h3><code class="docutils literal notranslate"><span class="pre">MultiFab</span></code><a class="headerlink" href="#multifab" title="Permalink to this headline">¶</a></h3>
<p>At the highest abstraction level, we have the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> (mulitple
FArrayBoxes). A <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> contains an array of <code class="docutils literal notranslate"><span class="pre">Box</span></code> es, including
boxes owned by other processors for the purpose of communication,
an array of MPI ranks specifying which MPI processor owns each <code class="docutils literal notranslate"><span class="pre">Box</span></code>,
and an array of pointers to <code class="docutils literal notranslate"><span class="pre">FArrayBoxes</span></code> owned by this MPI
processor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>a <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> is a collection of the boxes that together
make up a single level of data in the AMR hierarchy.</p>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> can have multiple components (like density, temperature,
…) as well as a perimeter of ghost cells to exchange data with
neighbors or implement boundary conditions (this is all reflected in
the underlying <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code>).</p>
<p>Parallelization in AMReX is done by distributing the FABs across
processors. Each processor knows which FABs are local to it. To loop
over all the boxes local to a processor, an <code class="docutils literal notranslate"><span class="pre">MFIter</span></code> is used (more
on this below).</p>
<p>High-level operations exist on <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s to add, subtract, multiply,
etc., them together or with scalars, so you don’t need to write out
loops over the data directly.</p>
<p>In Castro, <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s are one of the main data structures you will
interact with in the C++ portions of the code.</p>
</div>
<div class="section" id="statedata">
<span id="soft-sec-statedata"></span><h3><code class="docutils literal notranslate"><span class="pre">StateData</span></code><a class="headerlink" href="#statedata" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">StateData</span></code> is a class that essentially holds a pair of
<code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s: one at the old time and one at the new
time. AMReX knows how to interpolate in time between these states to
get data at any intermediate point in time. The main data that we care
about in Castro (the fluid state, gravitational potential, etc.) will
be stored as <code class="docutils literal notranslate"><span class="pre">StateData</span></code>. Essentially, data is made StateData in
Castro if we need it to be stored in checkpoints / plotfiles, and/or
we want it to be automatically interpolated when we refine.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code> stores an array of <code class="docutils literal notranslate"><span class="pre">StateData</span></code> (in a C++ array
called <code class="docutils literal notranslate"><span class="pre">state</span></code>). We index this array using integer keys (defined
via an enum in <code class="docutils literal notranslate"><span class="pre">Castro.H</span></code>). The state data is registered
with AMReX in <code class="docutils literal notranslate"><span class="pre">Castro_setup.cpp</span></code>.</p>
<p>Note that each of the different <code class="docutils literal notranslate"><span class="pre">StateData</span></code> carried in the state
array can have different numbers of components, ghost cells, boundary
conditions, etc. This is the main reason we separate all this data
into separate StateData objects collected together in an indexable
array.</p>
<p>The current <code class="docutils literal notranslate"><span class="pre">StateData</span></code> names Castro carries are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">State_Type</span></code> : this is the <code class="docutils literal notranslate"><span class="pre">NUM_STATE</span></code> hydrodynamics
components that make up the conserved hydrodynamics state (usually
referred to as <span class="math notranslate nohighlight">\(\Ub\)</span> in these notes. But note that this does
not include the radiation energy density.</p>
<p>In Fortran, the components of a FAB derived from <code class="docutils literal notranslate"><span class="pre">State_Type</span></code>
is indexed using the integer keys defined in <code class="docutils literal notranslate"><span class="pre">Castro_nd.F90</span></code>
and stored in <code class="docutils literal notranslate"><span class="pre">meth_params_module</span></code>, e.g., <code class="docutils literal notranslate"><span class="pre">URHO</span></code>, <code class="docutils literal notranslate"><span class="pre">UMX</span></code>,
<code class="docutils literal notranslate"><span class="pre">UMY</span></code>, …</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>regardless of dimensionality, we always carry around all
three velocity components. The “out-of-plane” components will
simply be advected, but we will allow rotation (in particular,
the Coriolis force) to affect them.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">State_Type</span></code> <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s have no ghost cells by default for
pure hydro and a single ghost cell by default when <code class="docutils literal notranslate"><span class="pre">RADIATION</span></code>
is enabled. There is an option to force them to have ghost cells by
setting the parameter <code class="docutils literal notranslate"><span class="pre">castro.state_nghost</span></code> at runtime.</p>
<p>Note that the prediction of the hydrodynamic state to the interface
will require 4 ghost cells. This accomodated by creating a separate
MultiFab, <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> that lives at the old-time level and
has the necessary ghost cells. We will describe this more later.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Rad_Type</span></code> : this stores the radiation energy density,
commonly denoted <span class="math notranslate nohighlight">\(E_r\)</span> in these notes. It has <code class="docutils literal notranslate"><span class="pre">nGroups</span></code>
components—the number of energy groups used in the multigroup
radiation hydrodynamics approximation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PhiGrav_Type</span></code> : this is simply the gravitational
potential, usually denoted <span class="math notranslate nohighlight">\(\Phi\)</span> in these notes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Gravity_Type</span></code> : this is the gravitational
acceleration. There are always 3 components, regardless of the
dimensionality (consistent with our choice of always carrying all 3
velocity components).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PhiRot_Type</span></code> : this is the rotational potential.
When rotation is enabled, this will store the effective potential
corresponding to the centrifugal force.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Source_Type</span></code> : this holds the time-rate of change of
the source terms, <span class="math notranslate nohighlight">\(d\Sb/dt\)</span>, for each of the <code class="docutils literal notranslate"><span class="pre">NUM_STATE</span></code>
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code> variables.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>we do not make use of the old-time quantity here. In
fact, we never allocate the <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> s for the old-time in
the <code class="docutils literal notranslate"><span class="pre">Source_Type</span></code> <code class="docutils literal notranslate"><span class="pre">StateData</span></code>, so there is not wasted
memory.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Reactions_Type</span></code> : this holds the data for the nuclear
reactions. It has <code class="docutils literal notranslate"><span class="pre">NumSpec+2</span></code> components: the species
creation rates (usually denoted <span class="math notranslate nohighlight">\(\omegadot_k\)</span> in these notes),
the specific energy generation rate (<span class="math notranslate nohighlight">\(\dot{e}_\mathrm{nuc}\)</span>),
and its density (<span class="math notranslate nohighlight">\(\rho \dot{e}_\mathrm{nuc}\)</span>).</p>
<p>These are stored as <code class="docutils literal notranslate"><span class="pre">StateData</span></code> so we have access to the reaction terms
outside of advance, both for diagnostics (like flame speed estimation)
and for reaction timestep limiting (this in particular needs the
data stored in checkpoints for continuity of timestepping upon restart).</p>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Mag_Type_x</span></code><span class="classifier">this is defined for MHD and stores the</span></dt><dd><p>face-centered (on x-faces) x-component of the magnetic field.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Mag_Type_y</span></code><span class="classifier">this is defined for MHD and stores the</span></dt><dd><p>face-centered (on y-faces) y-component of the magnetic field.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Mag_Type_z</span></code><span class="classifier">this is defined for MHD and stores the</span></dt><dd><p>face-centered (on z-faces) z-component of the magnetic field.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Simplified_SDC_React_Type</span></code> : this is used with the SDC
time-advancement algorithm. This stores the <code class="docutils literal notranslate"><span class="pre">NQSRC</span></code> terms
that describe how the primitive variables change over the timestep
due only to reactions. These are used when predicting the interface
states of the primitive variables for the hydrodynamics portion of the
algorithm.</p></li>
</ul>
<p>We access the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s that carry the data of interest by interacting
with the <code class="docutils literal notranslate"><span class="pre">StateData</span></code> using one of these keys. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">S_new</span> <span class="o">=</span> <span class="n">get_new_data</span><span class="p">(</span><span class="n">State_Type</span><span class="p">);</span>
</pre></div>
</div>
<p>gets a pointer to the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> containing the hydrodynamics state data
at the new time.</p>
</div>
<div class="section" id="various-source-multifabs">
<h3>Various source <code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code><a class="headerlink" href="#various-source-multifabs" title="Permalink to this headline">¶</a></h3>
<p>There are a number of different <code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code> (and arrays of <code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code>)
that hold source term information.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">hydro_source</span></code> : this is a <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> that holds the
update to the hydrodynamics (basically the divergence of the
fluxes). This is filled in the conservative update routine of the
hydrodynamics.</p>
<p>As this is expressed as a source term, what is actually stored is</p>
<div class="math notranslate nohighlight">
\[\Sb_\mathrm{flux} = -\nabla \cdot {\bf F}\]</div>
<p>So the update of the conserved state appears as:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \Ub}{\partial t} = \Sb_\mathrm{flux}\]</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sources_for_hydro</span></code> : a single <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> that stores
the sum of sources over each physical process.</p></li>
</ul>
</div>
</div>
<div class="section" id="mfiter-and-interacting-with-fortran">
<h2><code class="docutils literal notranslate"><span class="pre">MFIter</span></code> and interacting with Fortran<a class="headerlink" href="#mfiter-and-interacting-with-fortran" title="Permalink to this headline">¶</a></h2>
<p>The process of looping over boxes at a given level of refinement and
operating on their data in Fortran is linked to how Castro achieves
thread-level parallelism. The OpenMP approach in Castro has evolved
considerably since the original paper was written, with the modern
approach, called <em>tiling</em>, gearing up to meet the demands of
many-core processors in the next-generation of supercomputers. We
discuss the original and new approach together here.</p>
<p>In both cases, the key construct is the <code class="docutils literal notranslate"><span class="pre">MFiter</span></code>—this is a
C++ iterator that knows how to loop over the <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> es in the
<code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> that are local to the processor (in this way, a lot of the
parallelism is hidden from view).</p>
<div class="section" id="non-tiling-mfiter">
<span id="sec-amrex0"></span><h3>Non-Tiling MFIter<a class="headerlink" href="#non-tiling-mfiter" title="Permalink to this headline">¶</a></h3>
<p>The non-tiling way to iterate over the <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> s is <a class="footnote-reference brackets" href="#id5" id="id1">1</a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over boxes</span>
<span class="p">{</span>
  <span class="c1">// Get the index space of this iteration</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">validbox</span><span class="p">();</span>

  <span class="c1">// Get a reference to the FAB, which contains data and box</span>
  <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

  <span class="c1">// Get the index space for the data region in th FAB.</span>
  <span class="c1">// Note &quot;abox&quot; may have ghost cells, and is thus larger than</span>
  <span class="c1">// or equal to &quot;box&quot; obtained using mfi.validbox().</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

  <span class="c1">// We can now pass the information to a Fortran routine,</span>
  <span class="c1">// fab.dataPtr() gives a double*, which is reshaped into</span>
  <span class="c1">// a multi-dimensional array with dimensions specified by</span>
  <span class="c1">// the information in &quot;abox&quot;. We will also pass &quot;box&quot;,</span>
  <span class="c1">// which specifies our &quot;work&quot; region.</span>
  <span class="n">do_work</span><span class="p">(</span><span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">()),</span>
          <span class="n">fab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">fab</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span>
          <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
<p>A few comments about this code</p>
<ul>
<li><p>In this example, we are working off of a <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> named <code class="docutils literal notranslate"><span class="pre">mf</span></code>.
This could, for example, come from state data as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">mf</span> <span class="o">=</span> <span class="n">get_old_data</span><span class="p">(</span><span class="n">State_Type</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>We are passing the data in <code class="docutils literal notranslate"><span class="pre">mf</span></code> one box at a time to the
Fortran function <code class="docutils literal notranslate"><span class="pre">do_work</span></code>.</p></li>
<li><p>Here the <code class="docutils literal notranslate"><span class="pre">MFIter</span></code> iterator, <code class="docutils literal notranslate"><span class="pre">mfi</span></code>, will perform the loop
only over the boxes that are local to the MPI task. If there are 3
boxes on the processor, then this loop has 3 iterations.</p>
<p><code class="docutils literal notranslate"><span class="pre">++mfi</span></code> iterates to the next <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> owned by the
<code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> <code class="docutils literal notranslate"><span class="pre">mf</span></code>, and <code class="docutils literal notranslate"><span class="pre">mfi.isValid()</span></code> returns false
after we’ve reached the last box contained in the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code>,
terminating the loop.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">box</span></code> as returned from <code class="docutils literal notranslate"><span class="pre">mfi.validbox()</span></code> does not include
ghost cells. This is the valid data region only.
We can get the indices of the valid zones as <code class="docutils literal notranslate"><span class="pre">box.loVect()</span></code> and
<code class="docutils literal notranslate"><span class="pre">box.hiVect()</span></code>.</p>
<p>In passing to the Fortran function, we use the macro
<code class="docutils literal notranslate"><span class="pre">ARLIM_3D</span></code>, defined in <code class="docutils literal notranslate"><span class="pre">ArrayLim.H</span></code> to pass the <code class="docutils literal notranslate"><span class="pre">lo</span></code>
and <code class="docutils literal notranslate"><span class="pre">hi</span></code> vectors as pointers to an <code class="docutils literal notranslate"><span class="pre">int</span></code> array. This array
is defined to always be 3D, with 0s substituted for the
higher dimension values if we are running in 1- or 2D.</p>
<p>Passing the data in this 3D fashion is a newer approach in Castro.
This enables writing <em>dimension agnostic code</em>. There are many
other approaches that will pass only the <code class="docutils literal notranslate"><span class="pre">DIM</span></code> values of
<code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> using alternate macros in <code class="docutils literal notranslate"><span class="pre">ArrayLim.H</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">fab.dataPtr()</span></code> returns a <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">*</span></code>—a pointer to the
data region. This is what is passed to Fortran.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fab.nComp()</span></code> gives an int—the number of components
in the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code>. This will be used for dimensioning in Fortran.</p></li>
<li><p>To properly dimension the array in Fortran, we need the actual
bounds of the data region, including any ghost cells. This is the
<code class="docutils literal notranslate"><span class="pre">Box</span></code> <code class="docutils literal notranslate"><span class="pre">abox</span></code>, obtained as <code class="docutils literal notranslate"><span class="pre">fab.box()</span></code>. We pass the
<code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> of the full data region as well.</p></li>
</ul>
<p>To properly compile, we need a prototype for the Fortran
function. These are placed in the <code class="docutils literal notranslate"><span class="pre">*_F.H</span></code> files in the
<code class="docutils literal notranslate"><span class="pre">Castro/Source/</span></code> directory. Here’s the prototype for
our function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">do_work</span>
  <span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">hi</span><span class="p">,</span>
   <span class="n">Real</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span><span class="o">&amp;</span> <span class="n">ncomp</span>
   <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">s_lo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">s_hi</span><span class="p">)</span>
</pre></div>
</div>
<p>A few comments on the prototype:</p>
<ul class="simple">
<li><p>we use the <code class="docutils literal notranslate"><span class="pre">const</span></code> qualifier on the many of the arguments.
This indicates that the data that is pointed to cannot be
modified <a class="footnote-reference brackets" href="#id6" id="id2">2</a>, but the
contents of the memory space that they point to can be modified.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">ncomp</span></code>, we in the calling sequence, we just did
<code class="docutils literal notranslate"><span class="pre">fab.nComp()</span></code>. This returns a <code class="docutils literal notranslate"><span class="pre">int</span></code>. But Fortran is a
pass-by-reference language, so we make the argument in the prototype
a reference. This ensures that it is passed by reference.</p></li>
</ul>
<p>In our Fortran example, we want to loop over all of the data,
including 1 ghost cell all around. The corresponding Fortran function
will look like:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">do_work</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">state</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">s_lo</span><span class="p">,</span> <span class="n">s_hi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;do_work&quot;</span><span class="p">)</span>

  <span class="k">use </span><span class="n">prob_params_module</span><span class="p">,</span> <span class="n">only</span> <span class="p">:</span> <span class="n">dg</span>

  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span>

  <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">dp_t</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state</span><span class="p">(</span><span class="n">s_lo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span><span class="p">)</span>

  <span class="c">! loop over the data</span>
  <span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">*</span><span class="n">dg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

           <span class="c">! work on state(i,j,k,:), where the last index</span>
           <span class="c">! is the component of the multifab</span>

        <span class="n">enddo</span>
     <span class="n">enddo</span>
  <span class="n">enddo</span>

<span class="k">end subroutine </span><span class="n">do_work</span>
</pre></div>
</div>
<p>Finally, comments on the Fortran routine;</p>
<ul>
<li><p>We use the Fortran 2003 <code class="docutils literal notranslate"><span class="pre">bind</span></code> keyword to specify
that we want this to be interoperable with C. Ordinarily
we would not need to specify the optional argument name
in the binding, but the PGI compiler requires this if our
Fortran subroutine is part of a module.</p></li>
<li><p>We dimension state using <code class="docutils literal notranslate"><span class="pre">s_lo</span></code> and <code class="docutils literal notranslate"><span class="pre">s_hi</span></code> —these are
the bounds we got from the <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code>, and are for the entire data
region, including ghost cells.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Fortran, the spatial indices of state don’t
necessarily start at 1—they reflect the global index space for
the entire domain at this level of refinement. This means that
we know where the box is located.</p>
</div>
<p>Later we’ll see how to compute the spatial coordinates using this
information.</p>
</li>
<li><p>Our loop uses <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code>—these are the indices
of the valid data region (no ghost cells). Since we want a single
ghost cell all around, we subtract 1 from <code class="docutils literal notranslate"><span class="pre">lo</span></code> and add 1
to <code class="docutils literal notranslate"><span class="pre">hi</span></code>.</p>
<p>Finally, since this is dimension-agnostic code (it should work
correctly in 1-, 2-, and 3D), we need to ensure the loops over the
higher dimensions do nothing when we compile for a lower
dimensionality. This is the role of <code class="docutils literal notranslate"><span class="pre">dg</span></code>—dg is 1
if our simulation includes that spatial dimension and 0
otherwise.</p>
<p>If we were not looping over ghost cells too, then we would not need
to invoke <code class="docutils literal notranslate"><span class="pre">dg</span></code>, since <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> are both set to
0 for any dimensions not represented in our simulation.</p>
</li>
</ul>
<p>Up to this point, we have not said anything about threading. In this
style of using the MFIter, we implement the OpenMP in Fortran, for
instance by putting a pragma around the outer loop in this example.</p>
</div>
<div class="section" id="amrexs-current-tiling-approach-in-c">
<span id="sec-amrex1"></span><h3>AMReX’s Current Tiling Approach In C++<a class="headerlink" href="#amrexs-current-tiling-approach-in-c" title="Permalink to this headline">¶</a></h3>
<p>There are two types of tiling that people discuss. In <em>logical
tiling</em>, the data storage in memory is unchanged from how we do things
now in pure MPI. In a given box, the data region is stored
contiguously). But when we loop in OpenMP over a box, the tiling
changes how we loop over the data. The alternative is called
<em>separate tiling</em>—here the data storage in memory itself is changed
to reflect how the tiling will be performed. This is not considered
in AMReX.</p>
<p>We have recently introduced logical tiling into parts of AMReX.  It
is off by default, to make the transition smooth and because not
everything should be tiled. It can be enabled on a loop-by-loop basis
by setting an optional argument to <code class="docutils literal notranslate"><span class="pre">MFIter</span></code>. We demonstrate this
below. Further examples can be found at <code class="docutils literal notranslate"><span class="pre">amrex/Tutorials/Tiling_C</span></code>,
and <code class="docutils literal notranslate"><span class="pre">amrex/Src/LinearSolvers/C_CellMG/</span></code>.</p>
<p>In our logical tiling approach, a box is logically split into tiles,
and a <code class="docutils literal notranslate"><span class="pre">MFIter</span></code> loops over each tile in each box. Note that the
non-tiling iteration approach can be considered as a special case of
tiling with the tile size equal to the box size.</p>
<p>Let us consider an example. Suppose there are four boxes—see
<a class="reference internal" href="#fig-domain-tiling"><span class="std std-numref">Fig. 2</span></a>.</p>
<div class="figure align-default" id="id10">
<span id="fig-domain-tiling"></span><img alt="tiling of the domain" src="_images/domain-tile.png" />
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">A simple domain showing 4 Boxes labeled 0–3, and their tiling
regions (dotted lines)</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<p>The first box is divided into 4 logical tiles, the second and third
are divided into 2 tiles each (because they are small), and the fourth
into 4 tiles. So there are 12 tiles in total. The difference between
the tiling and non-tiling version are then:</p>
<ul class="simple">
<li><p>In the tiling version, the loop body will be run 12 times. Note
that <code class="docutils literal notranslate"><span class="pre">tilebox</span></code> is different for each tile, whereas <code class="docutils literal notranslate"><span class="pre">fab</span></code>
might be referencing the same object if the tiles belong to the same
box.</p></li>
<li><p>In the non-tiling version (by constructing <code class="docutils literal notranslate"><span class="pre">MFIter</span></code> without
the optional second argument or setting to false), the loop
body will be run 4 times because there are four boxes, and a call to
<code class="docutils literal notranslate"><span class="pre">mfi.tilebox()</span></code> will return the traditional <code class="docutils literal notranslate"><span class="pre">validbox</span></code>. The
non-tiling case is essentially having one tile per box.</p></li>
</ul>
<p>The tiling implementation of the same call to our the Fortran
do_work routine is show below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">tiling</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">MFIter</span> <span class="n">mfi</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">tiling</span><span class="p">);</span> <span class="n">mfi</span><span class="p">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">mfi</span><span class="p">)</span> <span class="c1">// Loop over tiles</span>
<span class="p">{</span>
  <span class="c1">// Get the index space of this iteration.</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">box</span> <span class="o">=</span> <span class="n">mfi</span><span class="p">.</span><span class="n">growntilebox</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Get a reference to the FAB, which contains data and box</span>
  <span class="n">FArrayBox</span><span class="o">&amp;</span> <span class="n">fab</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="n">mfi</span><span class="p">];</span>

  <span class="c1">// Get the index space for the data pointed by the double*.</span>
  <span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">abox</span> <span class="o">=</span> <span class="n">fab</span><span class="p">.</span><span class="n">box</span><span class="p">();</span>

  <span class="c1">// We can now pass the information to a Fortran routine.</span>
  <span class="n">do_work</span><span class="p">(</span><span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">box</span><span class="p">.</span><span class="n">hiVect</span><span class="p">()),</span>
          <span class="n">fab</span><span class="p">.</span><span class="n">dataPtr</span><span class="p">(),</span> <span class="n">fab</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span>
          <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">loVect</span><span class="p">()),</span> <span class="n">ARLIM_3D</span><span class="p">(</span><span class="n">abox</span><span class="p">.</span><span class="n">hiVect</span><span class="p">())</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Note that the code is almost identical to the one in § <a class="reference internal" href="#sec-amrex0"><span class="std std-ref">Non-Tiling MFIter</span></a>.
Some comments:</p>
<ul>
<li><p>The iterator now takes an extra argument to turn on tiling (set
to <code class="docutils literal notranslate"><span class="pre">true</span></code>).</p>
<p>There is another interface fo <code class="docutils literal notranslate"><span class="pre">MFIter</span></code> that can take an
<code class="docutils literal notranslate"><span class="pre">IntVect</span></code> that explicitly gives the tile size in each coordinate
direction. If we don’t explictly specify the tile size at the loop,
then the runtime parameter <code class="docutils literal notranslate"><span class="pre">fabarray.mfiter_tile_size</span></code>
can be used to set it globally.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">.validBox()</span></code> has the same meaning as in the non-tile
approach, so we don’t use it.
Since in this example, we want to include a single ghost cell in our
loop over the data, we use <code class="docutils literal notranslate"><span class="pre">.growntilebox(1)</span></code> (where the 1
here indicates a single ghost cell) to get the <code class="docutils literal notranslate"><span class="pre">Box</span></code> (and
corresponding <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code>) for the <em>current tile</em>, not
the entire data region. If instead, we just wanted the valid
region in Fortran, without any ghost cells, we would use
<code class="docutils literal notranslate"><span class="pre">.tilebox()</span></code>.</p></li>
<li><p>When passing into the Fortran routine, we still use the index
space of the entire <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> (including ghost cells), as seen in
the <code class="docutils literal notranslate"><span class="pre">abox</span></code> construction. This is needed to properly dimension
the array in Fortran.</p>
<p>The Fortran routine will declare a multidimensional array that is of
the same size as the entire box, but only work on the index space
identified by the tile-box (<code class="docutils literal notranslate"><span class="pre">box</span></code>).</p>
</li>
</ul>
<p>The Fortran code is almost the same as before, but now our loop
simply uses <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code>, since, by construction with
<code class="docutils literal notranslate"><span class="pre">.growntilebox(1)</span></code>, this already includes the single ghost cell
all around:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">do_work</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">state</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="p">&amp;</span>
                   <span class="n">s_lo</span><span class="p">,</span> <span class="n">s_hi</span><span class="p">)</span> <span class="k">bind</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;do_work&quot;</span><span class="p">)</span>

  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span>

  <span class="kt">real</span> <span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="n">dp_t</span><span class="p">),</span> <span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">state</span><span class="p">(</span><span class="n">s_lo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">&amp;</span>
                                           <span class="n">s_lo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">s_hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">ncomp</span><span class="p">)</span>

  <span class="c">! loop over the data</span>
  <span class="k">do </span><span class="n">k</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
     <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

           <span class="c">! work on state(i,j,k,:), where the last index</span>
           <span class="c">! is the component of the multifab</span>

        <span class="n">enddo</span>
     <span class="n">enddo</span>
  <span class="n">enddo</span>

<span class="k">end subroutine </span><span class="n">do_work</span>
</pre></div>
</div>
<p>The function prototype is unchanged.</p>
<p>Tiling provides us the opportunity of a coarse-grained approach for
OpenMP. Threading can be turned on by inserting the following line
above the for (<code class="docutils literal notranslate"><span class="pre">MFIter</span></code>…) line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#pragma omp parallel</span>
</pre></div>
</div>
<p>Note that the OpenMP pragma does not have a for—this is not
used when working with an iterator.</p>
<p>Assuming four threads are used in the above example, thread 0 will
work on 3 tiles from the first box, thread 1 on 1 tile from the first
box and 2 tiles from the second box, and so forth. Note that
OpenMP can be used even when tiling is turned off. In that case, the
OpenMP granularity is at the box level (and good performance would need
many boxes per MPI task).</p>
<p>The tile size for the three spatial dimensions can be set by a
parameter, e.g., <code class="docutils literal notranslate"><span class="pre">fabarray.mfiter_tile_size</span> <span class="pre">=</span> <span class="pre">1024000</span> <span class="pre">8</span> <span class="pre">8</span></code>. A
huge number like 1024000 will turn off tiling in that direction.
As noted above, the <code class="docutils literal notranslate"><span class="pre">MFIter</span></code> constructor can also take an explicit
tile size: <code class="docutils literal notranslate"><span class="pre">MFIter(mfi(mf,IntVect(128,16,32)))</span></code>.</p>
<p>Note that tiling can naturally transition from all threads working
on a single box to each thread working on a separate box as the boxes
coarsen (e.g., in multigrid).</p>
<p>The MFIter class provides some other useful functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mfi.validbox()</span></code> : The same meaning as before independent of tiling.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mfi.tilebox()</span></code> : The standard way of getting the bounds of the
current tile box. This will tile over the valid data region only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mfi.growntilebox(int)</span></code> : A grown tile box that includes
ghost cells at box boundaries only. Thus the returned boxes for a
<code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> are non-overlapping.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mfi.nodaltilebox(int)</span></code> : Returns non-overlapping
edge-type boxes for tiles. The argument is for direction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mfi.fabbox()</span></code> : Same as <code class="docutils literal notranslate"><span class="pre">mf[mfi].box()</span></code>.</p></li>
</ul>
<p>Finally we note that tiling is not always desired or better. The
traditional fine-grained approach coupled with dynamic scheduling is
more appropriate for work with unbalanced loads, such as chemistry
burning in cells by an implicit solver. Tiling can also create extra
work in the ghost cells of tiles.</p>
<div class="section" id="practical-details-in-working-with-tiling">
<h4>Practical Details in Working with Tiling<a class="headerlink" href="#practical-details-in-working-with-tiling" title="Permalink to this headline">¶</a></h4>
<p>With tiling, the OpenMP is now all in C++, and not in Fortran for all
modules except reactions and <code class="docutils literal notranslate"><span class="pre">initdata</span></code>.</p>
<p>It is the responsibility of the coder to make sure that the routines
within a tiled region are safe to use with OpenMP. In particular,
note that:</p>
<ul>
<li><p>tile boxes are non-overlapping</p></li>
<li><p>the union of tile boxes completely cover the valid region of the
fab</p></li>
<li><p>Consider working with a node-centered MultiFab, <code class="docutils literal notranslate"><span class="pre">ugdnv</span></code>, and
a cell-centered <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> <code class="docutils literal notranslate"><span class="pre">s</span></code>:</p>
<ul class="simple">
<li><p>with <code class="docutils literal notranslate"><span class="pre">mfi(s)</span></code>, the tiles are based on the cell-centered
index space. If you have an <span class="math notranslate nohighlight">\(8\times 8\)</span> box, then and 4 tiles,
then your tiling boxes will range from <span class="math notranslate nohighlight">\(0\rightarrow 3\)</span>,
<span class="math notranslate nohighlight">\(4\rightarrow 7\)</span>.</p></li>
<li><p>with <code class="docutils literal notranslate"><span class="pre">mfi(ugdnv)</span></code>, the tiles are based on nodal indices,
so your tiling boxes will range from <span class="math notranslate nohighlight">\(0\rightarrow 3\)</span>,
<span class="math notranslate nohighlight">\(4\rightarrow 8\)</span>.</p></li>
</ul>
</li>
<li><p>When updating routines to work with tiling, we need to
understand the distinction between the index-space of the entire box
(which corresponds to the memory layout) and the index-space of the
tile.</p>
<ul>
<li><p>In the C++ end, we pass (sometimes via the
<code class="docutils literal notranslate"><span class="pre">BL_TO_FORTRAN()</span></code> macro) the <code class="docutils literal notranslate"><span class="pre">loVect</span></code> and <code class="docutils literal notranslate"><span class="pre">hiVect</span></code> of the
entire box (including ghost cells). These are then used to
allocate the array in Fortran as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">precision</span> <span class="p">::</span> <span class="n">a</span><span class="p">(</span><span class="n">a_l1</span><span class="p">:</span><span class="n">a_h1</span><span class="p">,</span> <span class="n">a_l2</span><span class="p">:</span><span class="n">a_h2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>When tiling is used, we do not want to loop as do <code class="docutils literal notranslate"><span class="pre">a_l1</span></code>,
<code class="docutils literal notranslate"><span class="pre">a_h1</span></code>, but instead we need to loop over the tiling region. The
indices of the tiling region need to be passed into the Fortran
routine separately, and they come from the <code class="docutils literal notranslate"><span class="pre">mfi.tilebox()</span></code>
or <code class="docutils literal notranslate"><span class="pre">mfi.growntilebox()</span></code> statement.</p>
</li>
<li><p>In Fortran, when initializing an array to 0, do so only
over the tile region, not for the entire box. For a Fortran array
a, this means we cannot do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">a</span><span class="p">(:,:,:,:)</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>but instead must do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">(</span><span class="n">lo</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="n">hi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">lo</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span><span class="n">hi</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">lo</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span><span class="n">hi</span><span class="p">(</span><span class="mi">3</span><span class="p">),:)</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">lo()</span></code> and <code class="docutils literal notranslate"><span class="pre">hi()</span></code> are the index-space for the tile box
returned from <code class="docutils literal notranslate"><span class="pre">mfi.tilebox()</span></code> in C++ and passed into the Fortran
routine.</p>
</li>
<li><p>Look at <code class="docutils literal notranslate"><span class="pre">r_old_s</span></code> in <code class="docutils literal notranslate"><span class="pre">Exec/gravity_tests/DustCollapse/probdata.f90</span></code> as an
example of how to declare a <code class="docutils literal notranslate"><span class="pre">threadprivate</span></code> variable—this is then used
in <code class="docutils literal notranslate"><span class="pre">sponge_nd.f90</span></code>.</p></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="boundaries-fillpatch-and-fillpatchiterator">
<h2>Boundaries: <code class="docutils literal notranslate"><span class="pre">FillPatch</span></code> and <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code><a class="headerlink" href="#boundaries-fillpatch-and-fillpatchiterator" title="Permalink to this headline">¶</a></h2>
<p>AMReX calls the act of filling ghost cells a <em>fillpatch</em>
operation. Boundaries between grids are of two types. The first we
call “fine-fine”, which is two grids at the same level. The second
type is “coarse-fine”, which needs interpolation from the coarse grid
to fill the fine grid ghost cells. Both of these are part of the
fillpatch operation. Fine-fine fills are just a straight copy from
“valid regions” to ghost cells. Coarse-fine fills are enabled
because the <code class="docutils literal notranslate"><span class="pre">StateData</span></code> is not just arrays, they’re “State Data”,
which means that the data knows how to interpolate itself (in an
anthropomorphical sense). The type of interpolation to use is defined
in <code class="docutils literal notranslate"><span class="pre">Castro_setup.cpp</span></code>—search for
<code class="docutils literal notranslate"><span class="pre">cell_cons_interp</span></code>, for example—that’s “cell conservative
interpolation”, i.e., the data is cell-based (as opposed to
node-based or edge-based) and the interpolation is such that the
average of the fine values created is equal to the coarse value from
which they came. (This wouldn’t be the case with straight linear
interpolation, for example.)</p>
<p>Additionally, since <code class="docutils literal notranslate"><span class="pre">StateData</span></code> has an old and new timelevel,
the fill patch operation can interpolate to an intermediate time.</p>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>To illustrate the various ways we fill ghost cells and use the data,
let’s consider the following scenarios:</p>
<ul>
<li><p><em>You have state data that was defined with no ghost cells. You
want to create a new</em> <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> <em>containing a copy of that data with</em>
<code class="docutils literal notranslate"><span class="pre">NGROW</span></code> <em>ghost cells.</em></p>
<p>This is the case with <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> —the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> of the
hydrodynamic state that we use to kick-off the hydrodynamics
advance.</p>
<p><code class="docutils literal notranslate"><span class="pre">Sborder</span></code> is declared in <code class="docutils literal notranslate"><span class="pre">Castro.H</span></code> simply as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Multifab</span> <span class="n">Sborder</span><span class="p">;</span>
</pre></div>
</div>
<p>It is then allocated in <code class="docutils literal notranslate"><span class="pre">Castro::initialize_do_advance()</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Sborder</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">NUM_STATE</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">,</span> <span class="n">Fab_allocate</span><span class="p">);</span>
<span class="k">const</span> <span class="n">Real</span> <span class="n">prev_time</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">State_Type</span><span class="p">].</span><span class="n">prevTime</span><span class="p">();</span>
<span class="n">expand_state</span><span class="p">(</span><span class="n">Sborder</span><span class="p">,</span> <span class="n">prev_time</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">);</span>
</pre></div>
</div>
<p>Note in the call to <code class="docutils literal notranslate"><span class="pre">.define()</span></code>, we tell AMReX to already
allocate the data regions for the <code class="docutils literal notranslate"><span class="pre">FArrayBox</span></code> s that are part of
<code class="docutils literal notranslate"><span class="pre">Sborder</span></code>.</p>
<p>The actually filling of the ghost cells is done by
<code class="docutils literal notranslate"><span class="pre">Castro::expand_state()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AmrLevel</span><span class="o">::</span><span class="n">FillPatch</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">Sborder</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">,</span>
                    <span class="n">prev_time</span><span class="p">,</span> <span class="n">State_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NUM_STATE</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, we are filling the ng ghost cells of <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code>
<code class="docutils literal notranslate"><span class="pre">Sborder</span></code> at time prev_time. We are using the
<code class="docutils literal notranslate"><span class="pre">StateData</span></code> that is part of the current <code class="docutils literal notranslate"><span class="pre">Castro</span></code> object that we
are part of. Note: <code class="docutils literal notranslate"><span class="pre">FillPatch</span></code> takes an object reference as its
first argument, which is the object that contains the relevant
<code class="docutils literal notranslate"><span class="pre">StateData</span></code> —that is what the this pointer indicates.
Finally, we are copying the <code class="docutils literal notranslate"><span class="pre">State_Type</span></code> data components 0 to
<code class="docutils literal notranslate"><span class="pre">NUM_STATE</span></code> <a class="footnote-reference brackets" href="#id7" id="id3">3</a>.</p>
<p>The result of this operation is that <code class="docutils literal notranslate"><span class="pre">Sborder</span></code> will now have
<code class="docutils literal notranslate"><span class="pre">NUM_GROW</span></code> ghost cells consistent with the <code class="docutils literal notranslate"><span class="pre">State_Type</span></code>
data at the old time-level.</p>
</li>
<li><p><em>You have state data that was defined with</em> <code class="docutils literal notranslate"><span class="pre">NGROW</span></code> <em>ghost
cells. You want to ensure that the ghost cells are filled
(including any physical boundaries) with valid data.</em></p>
<p>This is very similar to the procedure shown above. The main
difference is that for the <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> that will be the target
of the ghost cell filling, we pass in a reference to the <code class="docutils literal notranslate"><span class="pre">StateData</span></code> itself.</p>
<p>The main thing you need to be careful of here, is that you
need to ensure that the the time you are at is consistent with
the <code class="docutils literal notranslate"><span class="pre">StateData</span></code> ’s time. Here’s an example from the radiation
portion of the code <code class="docutils literal notranslate"><span class="pre">MGFLDRadSolver.cpp</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Real</span> <span class="n">time</span> <span class="o">=</span> <span class="n">castro</span><span class="o">-&gt;</span><span class="n">get_state_data</span><span class="p">(</span><span class="n">Rad_Type</span><span class="p">).</span><span class="n">curTime</span><span class="p">();</span>
<span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">S_new</span> <span class="o">=</span> <span class="n">castro</span><span class="o">-&gt;</span><span class="n">get_new_data</span><span class="p">(</span><span class="n">State_Type</span><span class="p">);</span>

<span class="n">AmrLevel</span><span class="o">::</span><span class="n">FillPatch</span><span class="p">(</span><span class="o">*</span><span class="n">castro</span><span class="p">,</span> <span class="n">S_new</span><span class="p">,</span> <span class="n">ngrow</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">State_Type</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">S_new</span><span class="p">.</span><span class="n">nComp</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">S_new</span></code> is a pointer to the new-time-level
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code> <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code>. So this operation will use the
<code class="docutils literal notranslate"><span class="pre">State_Type</span></code> data to fill its own ghost cells. we fill the
<code class="docutils literal notranslate"><span class="pre">ngrow</span></code> ghost cells of the new-time-level <code class="docutils literal notranslate"><span class="pre">State_Type</span></code> data,
for all the components.</p>
<p>Note that in this example, because the <code class="docutils literal notranslate"><span class="pre">StateData</span></code> lives in the
<code class="docutils literal notranslate"><span class="pre">castro</span></code> object and we are working from the <code class="docutils literal notranslate"><span class="pre">Radiation</span></code> object,
we need to make reference to the current <code class="docutils literal notranslate"><span class="pre">castro</span></code> object
pointer. If this were all done within the <code class="docutils literal notranslate"><span class="pre">castro</span></code> object, then
the pointer will simply be <code class="docutils literal notranslate"><span class="pre">this</span></code>, as we saw above.</p>
</li>
<li><p><em>You have a</em> <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> <em>with some derived quantity. You want to
fill its ghost cells.</em></p>
<p><code class="docutils literal notranslate"><span class="pre">MultiFabs</span></code> have a <code class="docutils literal notranslate"><span class="pre">FillBoundary()</span></code> method that will fill all
the ghost cells between boxes at the same level. It will not fill
ghost cells at coarse-fine boundaries or at physical boundaries.</p>
</li>
<li><p><em>You want to loop over the FABs in state data, filling ghost cells
along the way</em></p>
<p>This is the job of the <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code>—this iterator is used
to loop over the grids and fill ghostcells. A key thing to keep in
mind about the <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code> is that you operate on a copy of
the data—the data is disconnected from the original source. If you
want to update the data in the source, you need to explicitly copy
it back. Also note: <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code> takes a <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code>, but this is
not filled—this is only used to get the grid layout. Finally, the
way the <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code> is implemented is that all the
communication is done first, and then the iterating over boxes
commences.</p>
<p>For example, the loop that calls <code class="docutils literal notranslate"><span class="pre">CA_UMDRV</span></code> (all the
hydrodynamics integration stuff) starts with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">FillPatchIterator</span> <span class="n">fpi</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">S_new</span><span class="p">,</span> <span class="n">NUM_GROW</span><span class="p">,</span>
                           <span class="n">time</span><span class="p">,</span> <span class="n">State_Type</span><span class="p">,</span> <span class="n">strtComp</span><span class="p">,</span> <span class="n">NUM_STATE</span><span class="p">);</span>
      <span class="n">fpi</span><span class="o">.</span><span class="n">isValid</span><span class="p">();</span> <span class="o">++</span><span class="n">fpi</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">FArrayBox</span> <span class="o">&amp;</span><span class="n">state</span> <span class="o">=</span> <span class="n">fpi</span><span class="p">();</span>
  <span class="n">Box</span> <span class="n">bx</span><span class="p">(</span><span class="n">fpi</span><span class="o">.</span><span class="n">validbox</span><span class="p">());</span>

  <span class="o">//</span> <span class="n">work</span> <span class="n">on</span> <span class="n">the</span> <span class="n">state</span> <span class="n">FAB</span><span class="o">.</span>  <span class="n">The</span> <span class="n">interior</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="n">cells</span> <span class="n">will</span>
  <span class="o">//</span> <span class="n">live</span> <span class="n">between</span> <span class="n">bx</span><span class="o">.</span><span class="n">loVect</span><span class="p">()</span> <span class="ow">and</span> <span class="n">bx</span><span class="o">.</span><span class="n">hiVect</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code> is the thing that distributes the
grids over processors and makes parallel “just work”. This fills the
single patch <code class="docutils literal notranslate"><span class="pre">fpi</span></code> , which has <code class="docutils literal notranslate"><span class="pre">NUM_GROW</span></code> ghost cells,
with data of type <code class="docutils literal notranslate"><span class="pre">State_Type</span></code> at time <code class="docutils literal notranslate"><span class="pre">time</span></code>,
starting with component strtComp and including a total of
<code class="docutils literal notranslate"><span class="pre">NUM_STATE</span></code> components.</p>
</li>
</ul>
<p>In general, one should never assume that ghostcells are valid, and
instead do a fill patch operation when in doubt. Sometimes we will
use a <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code> to fill the ghost cells into a <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code>
without an explict look. This is done as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FillPatchIterator</span> <span class="n">fpi</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="n">S_old</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">State_Type</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">NUM_STATE</span><span class="p">);</span>
<span class="n">MultiFab</span><span class="o">&amp;</span> <span class="n">state_old</span> <span class="o">=</span> <span class="n">fpi</span><span class="o">.</span><span class="n">get_mf</span><span class="p">();</span>
</pre></div>
</div>
<p>In this operation, state_old points to the internal
<code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> in the <code class="docutils literal notranslate"><span class="pre">FillPatchIterator</span></code>, by getting a reference to it as
<code class="docutils literal notranslate"><span class="pre">fpi.get_mf()</span></code>. This avoids a local copy.</p>
<p>Note that in the examples above, we see that only <code class="docutils literal notranslate"><span class="pre">StateData</span></code> can fill
physical boundaries (because these register how to fill the boundaries
when they are defined). There are some advanced operations in
AMReX that can get around this, but we do not use them in Castro.</p>
</div>
<div class="section" id="physical-boundaries">
<span id="soft-phys-bcs"></span><h3>Physical Boundaries<a class="headerlink" href="#physical-boundaries" title="Permalink to this headline">¶</a></h3>
<p id="index-0">Physical boundary conditions are specified by an integer index <a class="footnote-reference brackets" href="#id8" id="id4">4</a> in
the <code class="docutils literal notranslate"><span class="pre">inputs</span></code> file, using the <code class="docutils literal notranslate"><span class="pre">castro.lo_bc</span></code> and <code class="docutils literal notranslate"><span class="pre">castro.hi_bc</span></code> runtime
parameters. The generally supported boundary conditions are, their
corresponding integer key, and the action they take for the normal
velocity, transverse velocity, and generic scalar are shown in
<a class="reference internal" href="#table-castro-bcs"><span class="std std-numref">Table 22</span></a>.</p>
<p>The definition of the specific actions are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">INT_DIR</span></code>: data taken from other grids or interpolated</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EXT_DIR</span></code>: data specified on EDGE (FACE) of bndry</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HOEXTRAP</span></code>: higher order extrapolation to EDGE of bndry</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FOEXTRAP</span></code>: first order extrapolation from last cell in interior</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REFLECT_EVEN</span></code>: <span class="math notranslate nohighlight">\(F(-n) = F(n)\)</span> true reflection from interior cells</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REFLECT_ODD</span></code>: <span class="math notranslate nohighlight">\(F(-n) = -F(n)\)</span> true reflection from interior cells</p></li>
</ul>
<p>The actual registration of a boundary condition action to a particular
variable is done in <code class="docutils literal notranslate"><span class="pre">Castro_setup.cpp</span></code>. At the top we define arrays
such as <code class="docutils literal notranslate"><span class="pre">scalar_bc</span></code>, <code class="docutils literal notranslate"><span class="pre">norm_vel_bc</span></code>, etc, which say which kind of
bc to use on which kind of physical boundary.  Boundary conditions are
set in functions like <code class="docutils literal notranslate"><span class="pre">set_scalar_bc</span></code>, which uses the <code class="docutils literal notranslate"><span class="pre">scalar_bc</span></code>
pre-defined arrays. We also specify the name of the Fortran routine
that is responsible for filling the data there (e.g., <code class="docutils literal notranslate"><span class="pre">hypfill</span></code>).  These
routines are discussed more below.</p>
<p>If you want to specify a value at a function (like at an inflow
boundary), then you choose an <em>inflow</em> boundary at that face of
the domain. You then need to write the implementation code for this.
There is a centralized hydrostatic boundary condition that is implemented
this way—see <a class="reference internal" href="creating_a_problem.html#create-bcs"><span class="std std-ref">Boundary conditions</span></a>.</p>
<span id="table-castro-bcs"></span><table class="docutils align-default" id="id11">
<caption><span class="caption-number">Table 22 </span><span class="caption-text">Physical boundary conditions supported in Castro.</span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 19%" />
<col style="width: 19%" />
<col style="width: 21%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>name</strong></p></th>
<th class="head"><p><strong>integer</strong></p></th>
<th class="head"><p><strong>normal
velocity</strong></p></th>
<th class="head"><p><strong>transverse
velocity</strong></p></th>
<th class="head"><p><strong>scalars</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>interior</p></td>
<td><p>0</p></td>
<td><p>INT_DIR</p></td>
<td><p>INT_DIR</p></td>
<td><p>INT_DIR</p></td>
</tr>
<tr class="row-odd"><td><p>inflow</p></td>
<td><p>1</p></td>
<td><p>EXT_DIR</p></td>
<td><p>EXT_DIR</p></td>
<td><p>EXT_DIR</p></td>
</tr>
<tr class="row-even"><td><p>outflow</p></td>
<td><p>2</p></td>
<td><p>FOEXTRAP</p></td>
<td><p>FOEXTRAP</p></td>
<td><p>FOEXTRAP</p></td>
</tr>
<tr class="row-odd"><td><p>symmetry</p></td>
<td><p>3</p></td>
<td><p>REFLECT_ODD</p></td>
<td><p>REFLECT_EVEN</p></td>
<td><p>REFLECT_EVEN</p></td>
</tr>
<tr class="row-even"><td><p>slipwall</p></td>
<td><p>4</p></td>
<td><p>REFLECT_ODD</p></td>
<td><p>REFLECT_EVEN</p></td>
<td><p>REFLECT_EVEN</p></td>
</tr>
<tr class="row-odd"><td><p>noslipwall</p></td>
<td><p>5</p></td>
<td><p>REFLECT_ODD</p></td>
<td><p>REFLECT_EVEN</p></td>
<td><p>REFLECT_EVEN</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fluxregister">
<h3><code class="docutils literal notranslate"><span class="pre">FluxRegister</span></code><a class="headerlink" href="#fluxregister" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">FluxRegister</span></code> holds face-centered data at the boundaries of a box.
It is composed of a set of <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> s (one for each face, so 6 for
3D). A <code class="docutils literal notranslate"><span class="pre">FluxRegister</span></code> stores fluxes at coarse-fine interfaces,
and isused for the flux-correction step.</p>
</div>
</div>
<div class="section" id="other-amrex-concepts">
<h2>Other AMReX Concepts<a class="headerlink" href="#other-amrex-concepts" title="Permalink to this headline">¶</a></h2>
<p>There are a large number of classes that help define the structure of
the grids, metadata associate with the variables, etc. A good way to
get a sense of these is to look at the <code class="docutils literal notranslate"><span class="pre">.H</span></code> files in the
<code class="docutils literal notranslate"><span class="pre">amrex/Src/</span></code> directory.</p>
<div class="section" id="geometry-class">
<h3><code class="docutils literal notranslate"><span class="pre">Geometry</span></code> class<a class="headerlink" href="#geometry-class" title="Permalink to this headline">¶</a></h3>
<p>There is a <code class="docutils literal notranslate"><span class="pre">Geometry</span></code> object, <code class="docutils literal notranslate"><span class="pre">geom</span></code> for each level as part of
the <code class="docutils literal notranslate"><span class="pre">Castro</span></code> object (this is inhereted through <code class="docutils literal notranslate"><span class="pre">AmrLevel</span></code>).</p>
</div>
<div class="section" id="parmparse-class">
<h3><code class="docutils literal notranslate"><span class="pre">ParmParse</span></code> class<a class="headerlink" href="#parmparse-class" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="error-estimators">
<h3>Error Estimators<a class="headerlink" href="#error-estimators" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="gravity-class">
<h2><code class="docutils literal notranslate"><span class="pre">Gravity</span></code> class<a class="headerlink" href="#gravity-class" title="Permalink to this headline">¶</a></h2>
<p>There is a single <code class="docutils literal notranslate"><span class="pre">Gravity</span></code> object, <code class="docutils literal notranslate"><span class="pre">gravity</span></code>, that is a
static class member of the <code class="docutils literal notranslate"><span class="pre">Castro</span></code> object. This means that all
levels refer to the same <code class="docutils literal notranslate"><span class="pre">Gravity</span></code> object.</p>
<p>Within the <code class="docutils literal notranslate"><span class="pre">Gravity</span></code> object, there are pointers to the <code class="docutils literal notranslate"><span class="pre">Amr</span></code>
object (as <code class="docutils literal notranslate"><span class="pre">parent</span></code>), and all of the <code class="docutils literal notranslate"><span class="pre">AmrLevels</span></code> (as a <code class="docutils literal notranslate"><span class="pre">PArray</span></code>,
<code class="docutils literal notranslate"><span class="pre">LevelData</span></code>). The <code class="docutils literal notranslate"><span class="pre">gravity</span></code> object gets the geometry
information at each level through the parent <code class="docutils literal notranslate"><span class="pre">Amr</span></code> class.</p>
<p>The main job of the <code class="docutils literal notranslate"><span class="pre">gravity</span></code> object is to provide the potential
and gravitation acceleration for use in the hydrodynamic sources.
Depending on the approximation used for gravity, this could mean
calling the AMReX multigrid solvers to solve the Poisson equation.</p>
</div>
<div class="section" id="fortran-helper-modules">
<h2>Fortran Helper Modules<a class="headerlink" href="#fortran-helper-modules" title="Permalink to this headline">¶</a></h2>
<p>There are a number of modules that make data available to the Fortran
side of Castroor perform other useful tasks.</p>
<div class="section" id="amrex-constants-module">
<h3><code class="docutils literal notranslate"><span class="pre">amrex_constants_module</span></code><a class="headerlink" href="#amrex-constants-module" title="Permalink to this headline">¶</a></h3>
<p>This provides double precision constants as Fortran parameters, like
<code class="docutils literal notranslate"><span class="pre">ZERO</span></code>, <code class="docutils literal notranslate"><span class="pre">HALF</span></code>, and <code class="docutils literal notranslate"><span class="pre">ONE</span></code>.</p>
</div>
<div class="section" id="extern-probin-module">
<h3><code class="docutils literal notranslate"><span class="pre">extern_probin_module</span></code><a class="headerlink" href="#extern-probin-module" title="Permalink to this headline">¶</a></h3>
<p>This module provides access to the runtime parameters for the
microphysics routines (EOS, reaction network, etc.). The source for
this module is generated at compile type via a make rule that invokes
a python script. This will search for all of the <code class="docutils literal notranslate"><span class="pre">_parameters</span></code> files
in the external sources, parse them for runtime parameters, and build
the module.</p>
</div>
<div class="section" id="fundamental-constants-module">
<h3><code class="docutils literal notranslate"><span class="pre">fundamental_constants_module</span></code><a class="headerlink" href="#fundamental-constants-module" title="Permalink to this headline">¶</a></h3>
<p>This provides the CGS values of many physical constants.</p>
</div>
<div class="section" id="math-module">
<h3><code class="docutils literal notranslate"><span class="pre">math_module</span></code><a class="headerlink" href="#math-module" title="Permalink to this headline">¶</a></h3>
<p>This provides simple mathematical functions. At the moment, a cross
product routine.</p>
</div>
<div class="section" id="meth-params-module">
<h3><code class="docutils literal notranslate"><span class="pre">meth_params_module</span></code><a class="headerlink" href="#meth-params-module" title="Permalink to this headline">¶</a></h3>
<p>This module provides the integer keys used to access the state arrays
for both the conserved variables (<code class="docutils literal notranslate"><span class="pre">URHO</span></code>, <code class="docutils literal notranslate"><span class="pre">UMX</span></code>, <span class="math notranslate nohighlight">\(\ldots\)</span>)
and primitive variables (<code class="docutils literal notranslate"><span class="pre">QRHO</span></code>, <code class="docutils literal notranslate"><span class="pre">QU</span></code>, <span class="math notranslate nohighlight">\(\ldots\)</span>), as well as
the number of scalar variables.</p>
<p>It also provides the values of most of the <code class="docutils literal notranslate"><span class="pre">castro.*xxxx*</span></code>
runtime parameters.</p>
</div>
<div class="section" id="model-parser-module">
<h3><code class="docutils literal notranslate"><span class="pre">model_parser_module</span></code><a class="headerlink" href="#model-parser-module" title="Permalink to this headline">¶</a></h3>
<p>This module is built if <code class="docutils literal notranslate"><span class="pre">USE_MODELPARSER</span></code> = <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> is set in the
problem’s <code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code>. It then provides storage for the an initial
model and routines to read it in and interpolate onto the Castro grid.</p>
</div>
<div class="section" id="prob-params-module">
<span id="soft-prob-params"></span><h3><code class="docutils literal notranslate"><span class="pre">prob_params_module</span></code><a class="headerlink" href="#prob-params-module" title="Permalink to this headline">¶</a></h3>
<p>This module stores information about the domain and current level, and
is periodically synced up with the C++ driver. The information
available here is:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">physbc_lo</span></code>, <code class="docutils literal notranslate"><span class="pre">physbc_hi</span></code>: these are the boundary
condition types at the low and high ends of the domain, for each
coordinate direction. Integer keys, <code class="docutils literal notranslate"><span class="pre">Interior</span></code>, <code class="docutils literal notranslate"><span class="pre">Inflow</span></code>,
<code class="docutils literal notranslate"><span class="pre">Outflow</span></code>, <code class="docutils literal notranslate"><span class="pre">Symmetry</span></code>, <code class="docutils literal notranslate"><span class="pre">SlipWall</span></code>, and
<code class="docutils literal notranslate"><span class="pre">NoSlipWall</span></code> allow you to interpret the values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">center</span></code> is the center of the problem. Note—this is up
to the problem setup to define (in the <code class="docutils literal notranslate"><span class="pre">probinit</span></code> subroutine).
Alternately, it can be set at runtime via
<code class="docutils literal notranslate"><span class="pre">castro.center</span></code>.</p>
<p>Usually <code class="docutils literal notranslate"><span class="pre">center</span></code> will be the physical center of the domain,
but not always. For instance, for axisymmetric problems,
center may be on the symmetry axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">center</span></code> is used in the multipole gravity, hybrid advection
algorithm, rotation sources, for the point mass gravity, in
defining the center of the sponge, and in deriving the radial
velocity.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">coord_type</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dim</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dg</span></code></p></li>
<li><p><em>refining information</em></p></li>
</ul>
</div></blockquote>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Note: some older code will use a special AMReX preprocessor macro,
<code class="docutils literal notranslate"><span class="pre">BL_TO_FORTRAN</span></code>, defined in <code class="docutils literal notranslate"><span class="pre">ArrayLim.H</span></code>, that converts
the C++ <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> into a Fortran array and its <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> indices.
Additionally, some older code will wrap the Fortran subroutine name
in an additional preprocessor macro, <code class="docutils literal notranslate"><span class="pre">BL_FORT_PROC_CALL</span></code>
to handle the name mangling between Fortran and C. This later
macro is generally not needed any more because of Fortran 2003
interoperability with C (through the Fortran <code class="docutils literal notranslate"><span class="pre">bind</span></code> keyword).</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>the way to read these complicated
C declarations is right-to-left. So <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">lo</span></code> means
<code class="docutils literal notranslate"><span class="pre">lo</span></code> is a integer pointer to a memory space that is constant. See
<a class="reference external" href="https://isocpp.org/wiki/faq/const-correctness#ptr-to-const">https://isocpp.org/wiki/faq/const-correctness#ptr-to-const</a></p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>for clarity and continuity in this
documentation, some of the variable names have been changed
compared to the actual code</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>the integer values are defined in <code class="docutils literal notranslate"><span class="pre">BC_TYPES.H</span></code></p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="problem_setups.html" class="btn btn-neutral float-right" title="Distributed Problem Setups" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="FlowChart.html" class="btn btn-neutral float-left" title="Flowchart" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2018-2020, Castro development tem

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    


</body>
</html>