

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Gravity &mdash; Castro 19.12
 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"kth": "{{k_\\mathrm{th}}}", "gcc": "{\\mathrm{g~cm^{-3}}}", "cms": "{\\mathrm{cm~s^{-1}}}", "presunit": "{\\mathrm{dyn~cm^{-2}}}", "accelunit": "{\\mathrm{cm~s^{-2}}}", "ergg": "{\\mathrm{erg~g^{-1}}}", "Ab": "{{\\bf A}}", "eb": "{{\\bf e}}", "Fb": "{{\\bf F}}", "gb": "{{\\bf g}}", "Hb": "{{\\bf H}}", "ib": "{{\\bf i}}", "Ib": "{{\\bf I}}", "Kb": "{{\\bf K}}", "lb": "{{\\bf l}}", "Lb": "{{\\bf L}}", "nb": "{{\\bf n}}", "Pb": "{{\\bf P}}", "Qb": "{{\\bf Q}}", "rb": "{{\\bf r}}", "Rb": "{{\\bf R}}", "Sb": "{{\\bf S}}", "ub": "{{\\bf u}}", "Ub": "{{\\bf U}}", "xb": "{{\\bf x}}", "dt": "{\\Delta t}", "omegadot": "{\\dot\\omega}", "inp": "{{\\rm in}}", "outp": "{{\\rm out}}", "sync": "{{\\rm sync}}", "half": "{\\frac{1}{2}}", "myhalf": "{\\half}", "nph": "{{n+\\myhalf}}", "kpp": "{\\ensuremath{\\kappa_{\\mathrm{P}}}}", "kpr": "{\\ensuremath{\\kappa_{\\mathrm{R}}}}", "kpf": "{\\ensuremath{\\kappa_{\\mathrm{F}}}}", "vb": "{\\boldsymbol{v}}", "vbt": "{\\widetilde{\\vb}}", "rbt": "{\\widetilde{\\rb}}", "ob": "{\\boldsymbol{\\omega}}", "nablab": "{\\boldsymbol{\\nabla}}", "avg": ["{{\\left \\langle #1 \\right \\rangle}}", 1]}}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Diffusion" href="diffusion.html" />
    <link rel="prev" title="Hydrodynamics" href="Hydrodynamics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Castro
          

          
          </a>

          
            
            
              <div class="version">
                19.12

              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Castro basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction to Castro</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="inputs.html">Input Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="rp_intro.html">Runtime Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="FlowChart.html">Flowchart</a></li>
<li class="toctree-l1"><a class="reference internal" href="software.html">Software Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="creating_a_problem.html">Setting Up Your Own Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Parallel I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Plotfiles and Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="retry.html">Retry Mechanism</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption"><span class="caption-text">Castro reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="build_system.html">Build System Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="coding_conventions.html">Coding Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpu_porting.html">Offloading a routine to GPU</a></li>
<li class="toctree-l1"><a class="reference internal" href="Hydrodynamics.html">Hydrodynamics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Gravity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gravity-types">Gravity Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#integration-strategy">Integration Strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controls">Controls</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#types-of-approximations">Types of Approximations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constantgrav"><code class="docutils literal notranslate"><span class="pre">ConstantGrav</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#monopolegrav"><code class="docutils literal notranslate"><span class="pre">MonopoleGrav</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#poissongrav"><code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#poisson-boundary-conditions-2d">Poisson Boundary Conditions: 2D</a></li>
<li class="toctree-l4"><a class="reference internal" href="#poisson-boundary-conditions-3d">Poisson Boundary Conditions: 3D</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#prescribedgrav"><code class="docutils literal notranslate"><span class="pre">PrescribedGrav</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#point-mass">Point Mass</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gr-correction">GR correction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hydrodynamics-source-terms">Hydrodynamics Source Terms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="diffusion.html">Diffusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="rotation.html">Rotation</a></li>
<li class="toctree-l1"><a class="reference internal" href="sponge.html">Sponge</a></li>
<li class="toctree-l1"><a class="reference internal" href="radiation.html">Radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Particles.html">Tracer particles</a></li>
<li class="toctree-l1"><a class="reference internal" href="EOSNetwork.html">Microphysics</a></li>
<li class="toctree-l1"><a class="reference internal" href="sdc.html">Spectral Deferred Corrections</a></li>
<li class="toctree-l1"><a class="reference internal" href="AMR.html">Adaptive Mesh Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConvertCheckpoint.html">Checkpoint Embiggener</a></li>
<li class="toctree-l1"><a class="reference internal" href="self_consistent_field.html">Self-Consistent Field Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="MAESTRO_restart.html">Restarting from Maestro</a></li>
<li class="toctree-l1"><a class="reference internal" href="Verification.html">Verification</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="filelist.html">File list</a></li>
<li class="toctree-l1"><a class="reference internal" href="classlist.html">Class list</a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="zreferences.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Castro</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Gravity</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/gravity.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gravity">
<span id="ch-gravity"></span><h1>Gravity<a class="headerlink" href="#gravity" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="gravity-types">
<h3>Gravity Types<a class="headerlink" href="#gravity-types" title="Permalink to this headline">¶</a></h3>
<p>Castro can incorporate gravity as a constant, monopole approximation,
or a full Poisson solve. To enable gravity in the code, set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">USE_GRAV</span> <span class="o">=</span> <span class="n">TRUE</span>
</pre></div>
</div>
<p>in the <code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code>, and then turn it on in the inputs file
via <code class="docutils literal notranslate"><span class="pre">castro.do_grav</span></code> = 1. If you want to incorporate a point mass
(through <code class="docutils literal notranslate"><span class="pre">castro.point_mass</span></code>), you must have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">USE_POINTMASS</span> <span class="o">=</span> <span class="n">TRUE</span>
</pre></div>
</div>
<p>in the <code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code>.</p>
<p>There are currently four options for how gravity is calculated,
controlled by setting <code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code>. The options are
<code class="docutils literal notranslate"><span class="pre">ConstantGrav</span></code>, <code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>, <code class="docutils literal notranslate"><span class="pre">MonopoleGrav</span></code> or
<code class="docutils literal notranslate"><span class="pre">PrescribedGrav</span></code>. Again, these are only relevant if <code class="docutils literal notranslate"><span class="pre">USE_GRAV</span> <span class="pre">=</span>
<span class="pre">TRUE</span></code> in the <code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code> and <code class="docutils literal notranslate"><span class="pre">castro.do_grav</span></code> = 1 in the inputs
file. If both of these are set then the user is required to specify
the gravity type in the inputs file or the program will abort.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">make sure you have set the <code class="docutils literal notranslate"><span class="pre">center()</span></code> variable
appropriately for you problem.  This can be done either by directly
setting it in the <code class="docutils literal notranslate"><span class="pre">prob_params_module</span></code> or via the
<code class="docutils literal notranslate"><span class="pre">castro.center</span></code> runtime parameter.</p>
</div>
</div>
<div class="section" id="integration-strategy">
<h3>Integration Strategy<a class="headerlink" href="#integration-strategy" title="Permalink to this headline">¶</a></h3>
<p>Castro uses subcycling to integrate levels at different timesteps.
The gravity algorithm needs to respect this to obtain full accuracy.
When self-gravity is computed via a multigrid solve
(<code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span> <span class="pre">=</span> <span class="pre">PoissonGrav</span></code>), we correct for this (though
not for other gravity types). At coarse-fine interfaces, the stencil
used in the Laplacian understands the coarse-fine interface and is
different than the stencil used in the interior.</p>
<p>There are two types of solves that we discuss with AMR:</p>
<ul class="simple">
<li><em>composite solve</em> : This is a multilevel solve, starting at
a coarse level (usually level 0) and solving for the potential on
all levels up to the finest level.</li>
<li><em>level solve</em> : This solves for the potential only on
a particular level. Finer levels are ignored. At coarse-fine
interfaces, the data from the coarse levels acts as Dirichlet
boundary conditions for the current-level-solve.</li>
</ul>
<p>The overall integration strategy is as follows, and is similar to
the discussion in <a class="reference internal" href="zreferences.html#castro-i" id="id1">[castro_I]</a>. Briefly:</p>
<ul>
<li><p class="first">At the beginning of a simulation, we do a multilevel composite
solve (if <code class="docutils literal notranslate"><span class="pre">gravity.no_composite</span></code> = 0).</p>
<p>We also do a multilevel composite solve after each regrid.</p>
</li>
<li><p class="first">The old-time gravity on the coarse level is defined based on
this composite solve, but we also do a level solve on the coarse
level, and use it to determine the difference between the composite
solve and the level solve, and store that in a MultiFab.</p>
</li>
<li><p class="first">After the hydro advance on the coarse level, we do another level
solve, and use the (level solve - compositive solve) as a lagged
predictor of how much we need to add back to that level solve to get
an effective new-time value for phi on the coarse level, and that’s
what defines the phi used for the new-time gravity</p>
</li>
<li><p class="first">Then we do the fine grid timestep(s), each using the same
strategy</p>
</li>
<li><p class="first">At an AMR synchronization step across levels (see Section
<a class="reference internal" href="AMR.html#sec-amr-synchronization"><span class="std std-ref">Synchronization Algorithm</span></a> for a
description of when these synchronizations occur), if we’re
choosing to synchronize the gravitational field across levels
(<code class="docutils literal notranslate"><span class="pre">gravity.no_sync</span></code> = 0) we then do a solve starting from the coarse
grid that adjusts for the mismatch between the fine-grid phi and
the coarse-grid phi, as well as the mismatch between the fine-grid
density fluxes and the coarse-grid density fluxes, and add the
resulting sync solve phi to both the coarse and the fine level</p>
<p>Thus, to within the gravity error tolerance, you get the same final
result as if you had done a full composite solve at the end of the
timestep (assuming <code class="docutils literal notranslate"><span class="pre">gravity.no_sync</span></code> = 0).</p>
</li>
</ul>
<p>If you do <code class="docutils literal notranslate"><span class="pre">gravity.no_composite</span></code> = 1, then you never do a full
multilevel solve, and the gravity on any level is defined only by the
solve on that level. The only time this would be appropriate is if
the fine level(s) cover essentially all of the mass on the grid for
all time.</p>
</div>
<div class="section" id="controls">
<h3>Controls<a class="headerlink" href="#controls" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>For the full Poisson solver
(<code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> = <code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>), the behavior
of the full Poisson solve / multigrid solver is controlled by
<code class="docutils literal notranslate"><span class="pre">gravity.no_sync</span></code> and <code class="docutils literal notranslate"><span class="pre">gravity.no_composite</span></code>.</li>
<li>For isolated boundary conditions, and when
<code class="docutils literal notranslate"><span class="pre">gravity.gravity_type``=</span>&#160; <span class="pre">``PoissonGrav</span></code>, the parameters
<code class="docutils literal notranslate"><span class="pre">gravity.max_multipole_order</span></code> and
<code class="docutils literal notranslate"><span class="pre">gravity.direct_sum_bcs</span></code> control the accuracy of
the Dirichlet boundary conditions. These are described in
Section <a class="reference external" href="#sec-poisson-3d-bcs">2.3.2</a>.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">MonopoleGrav</span></code>, in 1D we must have <code class="docutils literal notranslate"><span class="pre">coord_sys</span></code> = 2, and in
2D we must have <code class="docutils literal notranslate"><span class="pre">coord_sys</span></code> = 1.</li>
</ul>
<p>The following parameters apply to gravity
solves:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> : how should we calculate gravity?
Can be <code class="docutils literal notranslate"><span class="pre">ConstantGrav</span></code>, <code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>, <code class="docutils literal notranslate"><span class="pre">MonopoleGrav</span></code>, or
<code class="docutils literal notranslate"><span class="pre">PrescribedGrav</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.const_grav</span></code> : if <code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> =
<code class="docutils literal notranslate"><span class="pre">ConstantGrav</span></code>, set the value of constant gravity (default: 0.0)</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.no_sync</span></code> : <code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> =
<code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>, do we perform the “sync solve”? (0 or 1; default: 0)</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.no_composite</span></code> : if gravity.gravity_type
= <code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>, whether to perform a composite solve (0 or 1;
default: 0)</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.max_solve_level</span></code> : maximum level to solve
for <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\mathbf{g}\)</span>; above this level, interpolate from
below (default: <code class="docutils literal notranslate"><span class="pre">MAX_LEV</span></code>-1)</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.abs_tol</span></code> : if <code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> = <code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>,
this is the absolute tolerance for the Poisson solve. You can
specify a single value for this tolerance (or do nothing, and get a
reasonable default value), and then the absolute tolerance used by
the multigrid solve is <code class="docutils literal notranslate"><span class="pre">abs_tol</span></code> <span class="math notranslate nohighlight">\(\times 4\pi G\,
\rho_{\text{max}}\)</span> where <span class="math notranslate nohighlight">\(\rho_{\text{max}}\)</span> is the maximum
value of the density on the domain. On fine levels, this absolute
tolerance is multiplied by (<code class="docutils literal notranslate"><span class="pre">ref_ratio</span></code>):sup:<cite>2</cite> to account
for the change in the absolute scale of the Laplacian operator. You
can also specify an array of values for <code class="docutils literal notranslate"><span class="pre">abs_tol</span></code>, one for each
possible level in the simulation, and then the scaling by
(<code class="docutils literal notranslate"><span class="pre">ref_ratio</span></code>):sup:<cite>2</cite> is not applied.</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.rel_tol</span></code> : if <code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> = <code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>,
this is the relative tolerance for the Poisson solve. By default it
is zero. You can specify a single value for this tolerance and it
will apply on every level, or you can specify an array of values
for <code class="docutils literal notranslate"><span class="pre">rel_tol</span></code>, one for each possible level in the
simulation. This replaces the old parameter <code class="docutils literal notranslate"><span class="pre">gravity.ml_tol</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.max_multipole_order</span></code> : if <code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> =
<code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>, this is the max <span class="math notranslate nohighlight">\(\ell\)</span> value to use for
multipole BCs (must be <span class="math notranslate nohighlight">\(\geq 0\)</span>; default: 0)</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.direct_sum_bcs</span></code> : if <code class="docutils literal notranslate"><span class="pre">gravity.gravity_type</span></code> =
<code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code>, evaluate BCs using exact sum (0 or 1; default: 0)</li>
<li><code class="docutils literal notranslate"><span class="pre">gravity.drdxfac</span></code> : ratio of dr for monopole gravity
binning to grid resolution</li>
</ul>
<p>The follow parameters affect the coupling of hydro and gravity:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">castro.do_grav</span></code> : turn on/off gravity</li>
<li><code class="docutils literal notranslate"><span class="pre">castro.moving_center</span></code> : do we recompute the center
used for the multipole gravity solver each step?</li>
<li><code class="docutils literal notranslate"><span class="pre">castro.point_mass</span></code> : point mass at the center of the star
(must be <span class="math notranslate nohighlight">\(\geq 0\)</span>; default: 0.0)</li>
</ul>
<p>Note that in the following, <code class="docutils literal notranslate"><span class="pre">MAX_LEV</span></code> is a hard-coded parameter
in <code class="docutils literal notranslate"><span class="pre">Source/Gravity.cpp</span></code> which is currently set to 15. It
determines how many levels can be tracked by the <code class="docutils literal notranslate"><span class="pre">Gravity</span></code> object.</p>
</div>
</div>
<div class="section" id="types-of-approximations">
<h2>Types of Approximations<a class="headerlink" href="#types-of-approximations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="constantgrav">
<h3><code class="docutils literal notranslate"><span class="pre">ConstantGrav</span></code><a class="headerlink" href="#constantgrav" title="Permalink to this headline">¶</a></h3>
<p>Gravity can be defined as constant in direction and magnitude,
defined in the inputs file by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gravity</span><span class="o">.</span><span class="n">const_grav</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9.8</span>
</pre></div>
</div>
<p>for example, to set the gravity to have magnitude <span class="math notranslate nohighlight">\(9.8\)</span> in the
negative <span class="math notranslate nohighlight">\(y\)</span>-direction if in 2D, negative <span class="math notranslate nohighlight">\(z\)</span>-direction if in 3-D.
The actual setting is done in Gravity.cpp as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grav</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">const_grav</span><span class="p">,</span> <span class="n">BL_SPACEDIM</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that at present we do not fill the gravitational potential
<span class="math notranslate nohighlight">\(\phi\)</span> in this mode; it will be set to zero.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">ConstantGrav</span></code> can only be used along a Cartesian direction
(vertical for 2D axisymmetric).</p>
</div>
<div class="section" id="monopolegrav">
<span id="sec-monopole-grav"></span><h3><code class="docutils literal notranslate"><span class="pre">MonopoleGrav</span></code><a class="headerlink" href="#monopolegrav" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">MonopoleGrav</span></code> integrates the mass distribution on the grid
in spherical shells, defining an enclosed mass and uses this
to compute the gravitational potential and acceleration in a
spherically-symmetric fashion.</p>
<ul>
<li><p class="first">In 1D spherical coordinates we compute</p>
<div class="math notranslate nohighlight">
\[g(r) = -\frac{G M_{\rm enclosed}}{ r^2}\]</div>
<p>where <span class="math notranslate nohighlight">\(M_{\rm enclosed}\)</span> is calculated from the density at
the time of the call.</p>
<p>For levels above the coarsest level we define the extent of that
level’s radial arrays as ranging from the center of the star (<span class="math notranslate nohighlight">\(r=0\)</span>)
to the cell at that level farthest away from the origin. If there
are gaps between fine grids in that range then we interpolate the
density from a coarser level in order to construct a continuous
density profile. We note that the location of values in the density
profile and in the gravitational field exactly match the location of
data at that level so there is no need to interpolate between points
when mapping the 1D radial profile of <span class="math notranslate nohighlight">\(g\)</span> back onto the original
grid.</p>
</li>
<li><p class="first">In 2D or 3D we compute a 1D radial average of density and use
this to compute gravity as a one-dimensional integral, then
interpolate the gravity vector back onto the Cartesian grid
cells. At the coarsest level we define the extent of the 1D arrays
as ranging from the center of the star to the farthest possible
point in the grid (plus a few extra cells so that we can fill ghost
cell values of gravity). At finer levels we first define a single
box that contains all boxes on that fine level, then we interpolate
density from coarser levels as needed to fill the value of density
at every fine cell in that box. The extent of the radial array is
from the center of the star to the <em>nearest</em> cell on one of the
faces of the single box. This ensures that all cells at that
maximum radius of the array are contained in this box.</p>
<p>We then average the density onto a 1D radial array. We note that
there is a mapping from the Cartesian cells to the radial array and
back; unlike the 1D case this requires interpolation. We use
quadratic interpolation with limiting so that the interpolation
does not create new maxima or minima.</p>
<p>The default resolution of the radial arrays at a level is the grid
cell spacing at that level, i.e., <span class="math notranslate nohighlight">\(\Delta r = \Delta x\)</span>.
For increased accuracy, one can define <code class="docutils literal notranslate"><span class="pre">gravity.drdxfac</span></code> as a number
greater than <span class="math notranslate nohighlight">\(1\)</span> (<span class="math notranslate nohighlight">\(2\)</span> or <span class="math notranslate nohighlight">\(4\)</span> are recommended) and
the spacing of the radial array will then satisfy <span class="math notranslate nohighlight">\(\Delta x /
\Delta r =\)</span> drdxfac.  Individual Cartesian grid cells are
subdivided by drdxfac in each coordinate direction for the
purposing of averaging the density, and the integration that
creates <span class="math notranslate nohighlight">\(g\)</span> is done at the finer resolution of the new
<span class="math notranslate nohighlight">\(\Delta r\)</span>.</p>
<p>Note that the center of the star is defined in the subroutine
<code class="docutils literal notranslate"><span class="pre">probinit</span></code> and the radius is computed as the distance from that
center.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">there is an additional correction at the corners in
<code class="docutils literal notranslate"><span class="pre">make_radial_grav</span></code> that accounts for the volume in a shell
that is not part of the grid.</p>
</div>
</li>
</ul>
<p>What about the potential in this case? when does
<code class="docutils literal notranslate"><span class="pre">make_radial_phi</span></code> come into play?</p>
</div>
<div class="section" id="poissongrav">
<h3><code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code><a class="headerlink" href="#poissongrav" title="Permalink to this headline">¶</a></h3>
<p>The most general case is a self-induced gravitational field,</p>
<div class="math notranslate nohighlight">
\[\mathbf{g}(\mathbf{x},t) = \nabla \phi\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi\)</span> is defined by solving</p>
<div class="math notranslate nohighlight" id="equation-eq-self-gravity">
<span class="eqno">(4)<a class="headerlink" href="#equation-eq-self-gravity" title="Permalink to this equation">¶</a></span>\[\mathbf{\Delta} \phi = 4 \pi G \rho\]</div>
<p>We only allow <code class="docutils literal notranslate"><span class="pre">PoissonGrav</span></code> in 2D or 3D because in 1D, computing
the monopole approximation in spherical coordinates is faster and more
accurate than solving the Poisson equation.</p>
<div class="section" id="poisson-boundary-conditions-2d">
<h4>Poisson Boundary Conditions: 2D<a class="headerlink" href="#poisson-boundary-conditions-2d" title="Permalink to this headline">¶</a></h4>
<p>In 2D, if boundary conditions are not periodic in both directions, we
use a monopole approximation at the coarsest level. This involves
computing an effective 1D radial density profile (on level = 0 only),
integrating it outwards from the center to get the gravitational
acceleration <span class="math notranslate nohighlight">\(\mathbf{g}\)</span>, and then integrating <span class="math notranslate nohighlight">\(g\)</span>
outwards from the center to get <span class="math notranslate nohighlight">\(\phi\)</span> (using <span class="math notranslate nohighlight">\(\phi(0) =
0\)</span> as a boundary condition, since no mass is enclosed at <span class="math notranslate nohighlight">\(r =
0\)</span>). For more details, see Section <a class="reference external" href="#sec-monopole-grav">2.2</a>.</p>
</div>
<div class="section" id="poisson-boundary-conditions-3d">
<span id="sec-poisson-3d-bcs"></span><h4>Poisson Boundary Conditions: 3D<a class="headerlink" href="#poisson-boundary-conditions-3d" title="Permalink to this headline">¶</a></h4>
<p>The following describes methods for doing isolated boundary
conditions. The best reference for Castro’s implementation of this
is <a class="reference internal" href="zreferences.html#katz-2016" id="id2">[katz:2016]</a>.</p>
<ul>
<li><p class="first"><strong>Multipole Expansion</strong></p>
<p>In 3D, by default, we use a multipole expansion to estimate the value
of the boundary conditions. According to, for example, Jackson’s
<em>Classical Electrodynamics</em> (with the corresponding change to
Poisson’s equation for electric charges and gravitational
”charges”), an expansion in spherical harmonics for <span class="math notranslate nohighlight">\(\phi\)</span> is</p>
<div class="math notranslate nohighlight" id="equation-spherical-harmonic-expansion">
<span class="eqno">(5)<a class="headerlink" href="#equation-spherical-harmonic-expansion" title="Permalink to this equation">¶</a></span>\[\phi(\mathbf{x}) = -G\sum_{l=0}^{\infty}\sum_{m=-l}^{l} \frac{4\pi}{2l + 1} q_{lm} \frac{Y_{lm}(\theta,\phi)}{r^{l+1}},\]</div>
<p>The origin of the coordinate system is taken to be the <code class="docutils literal notranslate"><span class="pre">center</span></code>
variable, that must be declared and stored in the <code class="docutils literal notranslate"><span class="pre">probdata</span></code>
module in your project directory. The validity of the expansion used
here is based on the assumption that a sphere centered on
<code class="docutils literal notranslate"><span class="pre">center</span></code>, of radius approximately equal to the size of half the
domain, would enclose all of the mass. Furthermore, the lowest order
terms in the expansion capture further and further departures from
spherical symmetry. Therefore, it is crucial that <code class="docutils literal notranslate"><span class="pre">center</span></code> be
near the center of mass of the system, for this approach to achieve
good results.</p>
<p>The multipole moments <span class="math notranslate nohighlight">\(q_{lm}\)</span> can be calculated by expanding the
Green’s function for the Poisson equation as a series of spherical
harmonics, which yields</p>
<div class="math notranslate nohighlight">
\[q_{lm} = \int Y^*_{lm}(\theta^\prime, \phi^\prime)\, {r^\prime}^l \rho(\mathbf{x}^\prime)\, d^3x^\prime. \label{multipole_moments_original}\]</div>
<p>Some simplification of <a class="reference internal" href="#equation-spherical-harmonic-expansion">(5)</a> can
be achieved by using the addition theorem for spherical harmonics:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  &amp;\frac{4\pi}{2l+1} \sum_{m=-l}^{l} Y^*_{lm}(\theta^\prime,\phi^\prime)\, Y_{lm}(\theta, \phi) = P_l(\text{cos}\, \theta) P_l(\text{cos}\, \theta^\prime) \notag \\
  &amp;\ \ + 2 \sum_{m=1}^{l} \frac{(l-m)!}{(l+m)!} P_{l}^{m}(\text{cos}\, \theta)\, P_{l}^{m}(\text{cos}\, \theta^\prime)\, \left[\text{cos}(m\phi)\, \text{cos}(m\phi^\prime) + \text{sin}(m\phi)\, \text{sin}(m\phi^\prime)\right].\end{aligned}\end{split}\]</div>
<p>Here the <span class="math notranslate nohighlight">\(P_{l}^{m}\)</span> are the associated Legendre polynomials and the
<span class="math notranslate nohighlight">\(P_l\)</span> are the Legendre polynomials. After some algebraic
simplification, the potential outside of the mass distribution can be
written in the following way:</p>
<div class="math notranslate nohighlight">
\[\phi(\mathbf{x}) \approx -G\sum_{l=0}^{l_{\text{max}}} \left[Q_l^{(0)} \frac{P_l(\text{cos}\, \theta)}{r^{l+1}} + \sum_{m = 1}^{l}\left[ Q_{lm}^{(C)}\, \text{cos}(m\phi) + Q_{lm}^{(S)}\, \text{sin}(m\phi)\right] \frac{P_{l}^{m}(\text{cos}\, \theta)}{r^{l+1}} \right].\]</div>
<p>The modified multipole moments are:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  Q_l^{(0)}   &amp;= \int P_l(\text{cos}\, \theta^\prime)\, {r^{\prime}}^l \rho(\mathbf{x}^\prime)\, d^3 x^\prime \\
  Q_{lm}^{(C)} &amp;= 2\frac{(l-m)!}{(l+m)!} \int P_{l}^{m}(\text{cos}\, \theta^\prime)\, \text{cos}(m\phi^\prime)\, {r^\prime}^l \rho(\mathbf{x}^\prime)\, d^3 x^\prime \\
  Q_{lm}^{(S)} &amp;= 2\frac{(l-m)!}{(l+m)!} \int P_{l}^{m}(\text{cos}\, \theta^\prime)\, \text{sin}(m\phi^\prime)\, {r^\prime}^l \rho(\mathbf{x}^\prime)\, d^3 x^\prime.\end{aligned}\end{split}\]</div>
<p>Our strategy for the multipole boundary conditions, then, is to pick
some value <span class="math notranslate nohighlight">\(l_{\text{max}}\)</span> that is of sufficiently high order to
capture the distribution of mass on the grid, evaluate the discretized
analog of the modified multipole moments for <span class="math notranslate nohighlight">\(0 \leq l \leq
l_{\text{max}}\)</span> and <span class="math notranslate nohighlight">\(1 \leq m \leq l\)</span>, and then directly compute the
value of the potential on all of the boundary zones. This is
ultimately an <span class="math notranslate nohighlight">\(\mathcal{O}(N^3)\)</span> operation, the same order as the
monopole approximation, and the wall time required to calculate the
boundary conditions will depend on the chosen value of
<span class="math notranslate nohighlight">\(l_{\text{max}}\)</span>.</p>
<p>The number of <span class="math notranslate nohighlight">\(l\)</span> values calculated is controlled by
<code class="docutils literal notranslate"><span class="pre">gravity.max_multipole_order</span></code> in your inputs file. By default, it
is set to <code class="docutils literal notranslate"><span class="pre">0</span></code>, which means that a monopole approximation is
used. There is currently a hard-coded limit of
<span class="math notranslate nohighlight">\(l_{\text{max}} = 50\)</span>. This is because the method used to
generate the Legendre polynomials is not numerically stable for
arbitrary <span class="math notranslate nohighlight">\(l\)</span> (because the polynomials get very large, for
large enough <span class="math notranslate nohighlight">\(l\)</span>).</p>
</li>
<li><p class="first"><strong>Direct Sum</strong></p>
<p>Up to truncation error caused by the discretization itself, the
boundary values for the potential can be computed exactly by a direct
sum over all cells in the grid. Suppose I consider some ghost cell
outside of the grid, at location <span class="math notranslate nohighlight">\(\mathbf{r}^\prime \equiv (x^\prime,
y^\prime, z^\prime)\)</span>. By the principle of linear superposition as
applied to the gravitational potential,</p>
<div class="math notranslate nohighlight">
\[\phi(\mathbf{r}^\prime) = \sum_{\text{ijk}} \frac{-G \rho_{\text{ijk}}\, \Delta V_{\text{ijk}}}{\left[(x - x^\prime)^2 + (y - y^\prime)^2 + (z - z^\prime)^2\right]^{1/2}},\]</div>
<p>where <span class="math notranslate nohighlight">\(x = x(i)\)</span>, <span class="math notranslate nohighlight">\(y = y(j)\)</span> and <span class="math notranslate nohighlight">\(z = z(k)\)</span> are
constructed in the usual sense from the zone indices. The sum here
runs over every cell in the physical domain (that is, the
calculation is <span class="math notranslate nohighlight">\(\mathcal{O}(N^3)\)</span> for each boundary
cell). There are <span class="math notranslate nohighlight">\(6N^2\)</span> ghost cells needed for the Poisson
solve (since there are six physical faces of the domain), so the
total cost of this operation is <span class="math notranslate nohighlight">\(\mathcal{O}(N^5)\)</span> (this only
operates on the coarse grid, at present). In practice, we use the
domain decomposition inherent in the code to implement this solve:
for the grids living on any MPI task, we create six <span class="math notranslate nohighlight">\(N^2\)</span>
arrays representing each of those faces, and then iterate over
every cell on each of those grids, and compute their respective
contributions to all of the faces. Then, we do a global reduce to
add up the contributions from all cells together. Finally, we place
the boundary condition terms appropriate for each grid onto its
respective cells.</p>
<p>This is quite expensive even for reasonable sized domains, so this
option is recommended only for analysis purposes, to check if the
other methods are producing accurate results. It can be enabled by
setting <code class="docutils literal notranslate"><span class="pre">gravity.direct_sum_bcs</span></code> = 1 in your inputs file.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="prescribedgrav">
<h3><code class="docutils literal notranslate"><span class="pre">PrescribedGrav</span></code><a class="headerlink" href="#prescribedgrav" title="Permalink to this headline">¶</a></h3>
<p>With PrescribedGrav <a class="footnote-reference" href="#id8" id="id3">[1]</a>, gravity can be defined as a function that is
specified by the user. The option is allowed in 2D and 3D. To define
the gravity vector, copy <code class="docutils literal notranslate"><span class="pre">prescribe_grav_nd.f90</span></code> from
<code class="docutils literal notranslate"><span class="pre">Source/gravity/</span></code> to your run directory. The makefile system will
always choose this local copy of the file over the one in another
directory.  Then define the components of gravity inside a loop over
the grid inside the file. If your problem uses a radial gravity in the
form <span class="math notranslate nohighlight">\(g(r)\)</span>, you can simply adapt
<code class="docutils literal notranslate"><span class="pre">ca_prescribe_grav_gravityprofile</span></code>, otherwise you will have to adapt
<code class="docutils literal notranslate"><span class="pre">ca_prescribe_grav</span></code>, both are located in <code class="docutils literal notranslate"><span class="pre">prescribed_grav_nd.90</span></code>.</p>
</div>
<div class="section" id="point-mass">
<h3>Point Mass<a class="headerlink" href="#point-mass" title="Permalink to this headline">¶</a></h3>
<p>Pointmass gravity works with all other forms of gravity, it is not a
separate option. Since the Poisson equation is linear in potential
(and its derivative, the acceleration, is also linear), the point mass
option works by adding the gravitational acceleration of the point
mass onto the acceleration from whatever other gravity type is under
in the simulation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the point mass have a mass &lt; 0</p>
</div>
<p>A useful option is <code class="docutils literal notranslate"><span class="pre">point_mass_fix_solution</span></code>. If set to 1, then it
takes all zones that are adjacent to the location of the center
variable and keeps their density constant. Any changes in density that
occur after a hydro update in those zones are reset, and the mass
deleted is added to the pointmass. (If there is expansion, and the
density lowers, then the point mass is reduced and the mass is added
back to the grid). This calculation is done in
<code class="docutils literal notranslate"><span class="pre">pm_compute_delta_mass()</span></code> in <code class="docutils literal notranslate"><span class="pre">Source/gravity/pointmass_nd.f90</span></code>.</p>
</div>
</div>
<div class="section" id="gr-correction">
<h2>GR correction<a class="headerlink" href="#gr-correction" title="Permalink to this headline">¶</a></h2>
<p>In the cases of compact objects or very massive stars, the general
relativity (GR) effect starts to play a role <a class="footnote-reference" href="#id9" id="id4">[2]</a>. First, we consider
the hydrostatic equilibrium due to effects of GR then derive
GR-correction term for Newtonian gravity.  The correction term is
applied to the monopole approximation only when <code class="docutils literal notranslate"><span class="pre">USE_GR</span></code> = TRUE is
set in the <code class="docutils literal notranslate"><span class="pre">GNUmakefile</span></code>.</p>
<p>The formulae of GR-correction here are based on
<a class="reference internal" href="zreferences.html#grbk1" id="id5">[grbk1]</a>. For detailed physics, please refer to
<a class="reference internal" href="zreferences.html#grbk2" id="id6">[grbk2]</a>. For describing very strong gravitational
field, we need to use Einstein field equations</p>
<div class="math notranslate nohighlight" id="equation-field">
<span class="eqno">(6)<a class="headerlink" href="#equation-field" title="Permalink to this equation">¶</a></span>\[R_{ik}-\frac{1}{2}g_{ik}R=\frac{\kappa}{c^{2}}T_{ik} \quad , \quad
\kappa=\frac{8\pi G}{c^{2}}\quad ,\]</div>
<p>where <span class="math notranslate nohighlight">\(R_{ik}\)</span> is the Ricci tensor, <span class="math notranslate nohighlight">\(g_{ik}\)</span> is the metric
tensor, <span class="math notranslate nohighlight">\(R\)</span> is the Riemann curvature, <span class="math notranslate nohighlight">\(c\)</span> is the speed of
light and <span class="math notranslate nohighlight">\(G\)</span> is gravitational constant. <span class="math notranslate nohighlight">\(T_{ik}\)</span> is the
energy momentum tensor, which for ideal gas has only the non-vanishing
components <span class="math notranslate nohighlight">\(T_{00}\)</span> = <span class="math notranslate nohighlight">\(\varrho c^2\)</span> , <span class="math notranslate nohighlight">\(T_{11}\)</span> =
<span class="math notranslate nohighlight">\(T_{22}\)</span> = <span class="math notranslate nohighlight">\(T_{33}\)</span> = <span class="math notranslate nohighlight">\(P\)</span> ( contains rest mass and
energy density, <span class="math notranslate nohighlight">\(P\)</span> is pressure). We are interested in
spherically symmetric mass distribution. Then the line element
<span class="math notranslate nohighlight">\(ds\)</span> for given spherical coordinate <span class="math notranslate nohighlight">\((r, \vartheta,
\varphi)\)</span> has the general form</p>
<div class="math notranslate nohighlight">
\[\label{metric}
  ds^{2} = e^{\nu}c^{2}dt^{2}-e^{\lambda}dr^{2}-r^{2}(d\vartheta^{2}+\sin^{2}
  \vartheta d\varphi) \quad ,\]</div>
<p>with <span class="math notranslate nohighlight">\(\nu = \nu(r)\)</span>, <span class="math notranslate nohighlight">\(\lambda = \lambda(r)\)</span>. Now we can
put the expression of <span class="math notranslate nohighlight">\(T_{ik}\)</span> and <span class="math notranslate nohighlight">\(ds\)</span> into <a class="reference internal" href="#equation-field">(6)</a>,
then field equations can be reduced to 3 ordinary differential
equations:</p>
<div class="math notranslate nohighlight" id="equation-diff1">
<span class="eqno">(7)<a class="headerlink" href="#equation-diff1" title="Permalink to this equation">¶</a></span>\[\frac{\kappa P}{c^{2}} =
   e^{-\lambda}\left (\frac{\nu^{\prime}}{r}+\frac{1}{r^{2}} \right )-\frac{1}{r^{2}}
   \quad ,\]</div>
<div class="math notranslate nohighlight" id="equation-diff2">
<span class="eqno">(8)<a class="headerlink" href="#equation-diff2" title="Permalink to this equation">¶</a></span>\[\frac{\kappa P}{c^{2}} =
  \frac{1}{2}e^{-\lambda}\left (\nu^{\prime\prime}+\frac{1}{2}{\nu^{\prime}}^{2}+\frac{\nu^
    {\prime}-\lambda^{\prime}}{r}
   -\frac{\nu^{\prime}\lambda^{\prime}}{2} \right ) \quad ,\]</div>
<div class="math notranslate nohighlight" id="equation-diff3">
<span class="eqno">(9)<a class="headerlink" href="#equation-diff3" title="Permalink to this equation">¶</a></span>\[\kappa \varrho =
  e^{-\lambda}\left (\frac{\lambda^{\prime}}{r}-\frac{1}{r^{2}}\right )+\frac{1}{r^{2}} \quad ,\]</div>
<p>where primes means the derivatives with respect to <span class="math notranslate nohighlight">\(r\)</span>. After
multiplying with <span class="math notranslate nohighlight">\(4\pi r^2\)</span>, <a class="reference internal" href="#equation-diff3">(9)</a> can be
integrated and yields</p>
<div class="math notranslate nohighlight">
\[\label{gmass1}
  \kappa m = 4\pi r (1-e^{-\lambda}) \quad ,\]</div>
<p>the <span class="math notranslate nohighlight">\(m\)</span> is called “gravitational mass” inside r defined as</p>
<div class="math notranslate nohighlight">
\[\label{gmass2}
  m = \int_{0}^{r}4\pi r^{2}  \varrho dr\quad .\]</div>
<p>For the <span class="math notranslate nohighlight">\(r = R\)</span>, <span class="math notranslate nohighlight">\(m\)</span> becomes the mass <span class="math notranslate nohighlight">\(M\)</span> of the
star. <span class="math notranslate nohighlight">\(M\)</span> contains not only the rest mass but the whole energy
(divided by <span class="math notranslate nohighlight">\(c^2\)</span>), that includes the internal and gravitational
energy. So the <span class="math notranslate nohighlight">\(\varrho = \varrho_0 +U/c^2\)</span> contains the whole
energy density <span class="math notranslate nohighlight">\(U\)</span> and rest-mass density
<span class="math notranslate nohighlight">\(\varrho_0\)</span>. Differentiation of <a class="reference internal" href="#equation-diff1">(7)</a> with respect to
<span class="math notranslate nohighlight">\(r\)</span> gives <span class="math notranslate nohighlight">\(P = P^{\prime}(\lambda,\lambda^{\prime},
\nu,\nu^{\prime},r)\)</span>, where
<span class="math notranslate nohighlight">\(\lambda,\lambda^{\prime},\nu,\nu^{\prime}\)</span> can be eliminated by
<a class="reference internal" href="#equation-diff1">(7)</a>, <a class="reference internal" href="#equation-diff2">(8)</a>, <a class="reference internal" href="#equation-diff3">(9)</a>. Finally we reach
<em>Tolman-Oppenheinmer-Volkoff (TOV)</em> equation for hydrostatic
equilibrium in general relativity:</p>
<div class="math notranslate nohighlight" id="equation-tov">
<span class="eqno">(10)<a class="headerlink" href="#equation-tov" title="Permalink to this equation">¶</a></span>\[\frac{dP}{dr} = -\frac{Gm}{r^{2}}\varrho \left (1+\frac{P}{\varrho
    c^{2}}\right )\left (1+\frac{4\pi r^3 P}{m c^{2}}\right ) \left (1-\frac{2Gm}{r c^{2}} \right)^{-1} \quad .\]</div>
<p>For Newtonian case <span class="math notranslate nohighlight">\(c^2 \rightarrow  \infty\)</span>, it reverts to usual form</p>
<div class="math notranslate nohighlight">
\[\label{newton}
  \frac{dP}{dr} = -\frac{Gm}{r^{2}}\varrho \quad .\]</div>
<p>Now we take effective monopole gravity as</p>
<div class="math notranslate nohighlight" id="equation-tov2">
<span class="eqno">(11)<a class="headerlink" href="#equation-tov2" title="Permalink to this equation">¶</a></span>\[\tilde{g} = -\frac{Gm}{r^{2}} (1+\frac{P}{\varrho
  c^{2}})(1+\frac{4\pi r^3 P}{m c^{2}}) (1-\frac{2Gm}{r c^{2}})^{-1}  \quad .\]</div>
<p>For general situations, we neglect the <span class="math notranslate nohighlight">\(U/c^2\)</span> and potential
energy in m because they are usually much smaller than
<span class="math notranslate nohighlight">\(\varrho_0\)</span>. Only when <span class="math notranslate nohighlight">\(T\)</span> reaches <span class="math notranslate nohighlight">\(10^{13} K\)</span>
(<span class="math notranslate nohighlight">\(KT \approx m_{p} c^2\)</span>, <span class="math notranslate nohighlight">\(m_p\)</span> is proton mass) before it
really makes a difference. So <a class="reference internal" href="#equation-tov2">(11)</a> can be expressed as</p>
<div class="math notranslate nohighlight">
\[\label{tov3}
  \tilde{g} = -\frac{GM_{\rm enclosed}}{r^{2}} \left (1+\frac{P}{\varrho
    c^{2}} \right )\left (1+\frac{4\pi r^3 P}{M_{\rm enclosed} c^{2}} \right ) \left (1-\frac{2GM_{\rm enclosed}}{r c^{2}} \right )^{-1} \quad ,\]</div>
<p>where <span class="math notranslate nohighlight">\(M_{enclosed}\)</span> has the same meaning as with the
<code class="docutils literal notranslate"><span class="pre">MonopoleGrav</span></code> approximation.</p>
</div>
<div class="section" id="hydrodynamics-source-terms">
<h2>Hydrodynamics Source Terms<a class="headerlink" href="#hydrodynamics-source-terms" title="Permalink to this headline">¶</a></h2>
<p>There are several options to incorporate the effects of gravity into
the hydrodynamics system. The main parameter here is
<code class="docutils literal notranslate"><span class="pre">castro.grav_source_type</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">castro.grav_source_type</span></code> = 1 : we use a standard
predictor-corrector formalism for updating the momentum and
energy. Specifically, our first update is equal to <span class="math notranslate nohighlight">\(\Delta t
\times \mathbf{S}^n\)</span> , where <span class="math notranslate nohighlight">\(\mathbf{S}^n\)</span> is the value of
the source terms at the old-time (which is usually called time-level
<span class="math notranslate nohighlight">\(n\)</span>). At the end of the timestep, we do a corrector step where
we subtract off <span class="math notranslate nohighlight">\(\Delta t / 2 \times \mathbf{S}^n\)</span> and add on
<span class="math notranslate nohighlight">\(\Delta t / 2 \times \mathbf{S}^{n+1}\)</span>, so that at the end of
the timestep the source term is properly time centered.</li>
<li><code class="docutils literal notranslate"><span class="pre">castro.grav_source_type</span></code> = 2 : we do something very similar
to 1. The major difference is that when evaluating the energy source
term at the new time (which is equal to <span class="math notranslate nohighlight">\(\mathbf{u} \cdot
\mathbf{S}^{n+1}_{\rho \mathbf{u}}\)</span>, where the latter is the
momentum source term evaluated at the new time), we first update the
momentum, rather than using the value of <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> before
entering the gravity source terms. This permits a tighter coupling
between the momentum and energy update and we have seen that it
usually results in a more accurate evolution.</li>
<li><code class="docutils literal notranslate"><span class="pre">castro.grav_source_type</span></code> = 3 : we do the same momentum update as
the previous two, but for the energy update, we put all of the work
into updating the kinetic energy alone. In particular, we explicitly
ensure that <span class="math notranslate nohighlight">\((\rho e)\)</span> remains the same, and update
<span class="math notranslate nohighlight">\((\rho K)\)</span> with the work due to gravity, adding the new kinetic
energy to the old internal energy to determine the final total gas
energy. The physical motivation is that work should be done on the
velocity, and should not directly update the temperature—only
indirectly through things like shocks.</li>
<li><code class="docutils literal notranslate"><span class="pre">castro.grav_source_type</span></code> = 4 : the energy update is done in a
“conservative” fashion. The previous methods all evaluate the value
of the source term at the cell center, but this method evaluates the
change in energy at cell edges, using the hydrodynamical mass
fluxes, permitting total energy to be conserved (excluding possible
losses at open domain boundaries). See
<a class="reference internal" href="zreferences.html#katzthesis" id="id7">[katzthesis]</a> for some more details.</li>
</ul>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>Note: The <code class="docutils literal notranslate"><span class="pre">PrescribedGrav</span></code>
option and text here were contributed by Jan Frederik Engels of
University of Gottingen.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>Note: The GR
code and text here were contributed by Ken Chen of Univ. of
Minnesota.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="diffusion.html" class="btn btn-neutral float-right" title="Diffusion" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Hydrodynamics.html" class="btn btn-neutral float-left" title="Hydrodynamics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Castro development tem

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>