#!/usr/bin/env python3

"""This routine parses plain-text parameter files that list runtime
parameters for use in our codes.  The general format of a parameter
is:

max_step                            integer            1
small_dt                            real               1.d-10
xlo_boundary_type                   character          ""
octant                              logical            .false.

This specifies the parameter name, datatype, and default
value.

The optional 4th column indicates whether the parameter appears
in the fortin namelist ("y" or "Y").

If the parameter is an array, the optional 5th column indicates the size of
the array.  If the size is a variable from a module, then a tuple is provided
in the form (size, module-name)

This script takes a template file and replaces keywords in it
(delimited by @@...@@) with the Fortran code required to
initialize the parameters, setup a namelist, set the defaults, etc.

Note: there are two types of parameters here, the ones that are in the
namelist are true runtime parameters.  The non-namelist parameters
should be avoided if at all possible.

"""

import argparse
import os
import re
import sys

HEADER = """
! DO NOT EDIT THIS FILE!!!
!
! This file is automatically generated by write_probdata.py at
! compile-time.
!
! To add a runtime parameter, do so by editting the appropriate _prob_params
! file.

"""

CXX_F_HEADER = """
#ifndef problem_parameters_F_H
#define problem_parameters_F_H
#include <AMReX.H>
#include <AMReX_BLFort.H>

#ifdef __cplusplus
#include <AMReX.H>
extern "C"
{
#endif

void probdata_init(const int* name, const int* namlen);
"""

CXX_F_FOOTER = """
#ifdef __cplusplus
}
#endif

#endif
"""

CXX_HEADER = """
#ifndef problem_parameters_H
#define problem_parameters_H
#include <AMReX_BLFort.H>

"""

CXX_FOOTER = """
#endif
"""

class Parameter:
    # the simple container to hold the runtime parameters
    def __init__(self):
        self.var = ""
        self.dtype = ""
        self.value = ""
        self.module = None
        self.size = 1
        self.in_namelist = False

    def get_f90_decl(self):
        """ get the Fortran 90 declaration """
        if self.dtype == "real":
            return "real (kind=rt)"
        elif self.dtype == "character":
            return "character (len=256)"

        return self.dtype

    def get_cxx_decl(self):
        """ get the Fortran 90 declaration """
        if self.dtype == "real":
            return "amrex::Real"
        elif self.dtype == "character":
            return None

        return "int"

    def is_array(self):
        try:
            isize = int(self.size)
        except ValueError:
            return True
        else:
            if isize == 1:
                return False
            else:
                return True

    def has_module(self):
        return self.module != None

    def __str__(self):
        return "{} : {}, {} elements".format(self.var, self.dtype, self.size)


def get_next_line(fin):
    """return the next, non-blank line, with comments stripped"""
    line = fin.readline()

    pos = line.find("#")

    while (pos == 0 or line.strip() == "") and line:
        line = fin.readline()
        pos = line.find("#")

    return line[:pos]


def parse_param_file(default_param_file, prob_param_file):
    """read all the parameters in both the default parameter file and
    the problem-specific parameter file and add valid parameters to the
    params list.  This returns the parameter list.
    """

    err = 0
    params_list = []

    for param_file in [default_param_file, prob_param_file]:

        # The default parameter file has to exist, but the
        # problem-specific parameter file is optional, so
        # skip it if it's not present.
        if os.path.isfile(param_file):
            f = open(param_file, "r")
        else:
            if param_file == default_param_file:
                sys.exit("write_probdata.py: ERROR: file {} does not exist".format(param_file))
            else:
                continue

        line = get_next_line(f)

        while line and not err:

            # this splits the line into separate fields.  A field is a
            # single word or a pair in parentheses like "(a, b)"
            fields = re.findall(r'[\w\"\+\./\-]+|\([\w+\./\-]+\s*,\s*[\w\+\.\-]+\)', line)

            if len(fields) < 3:
                print("write_probdata.py: ERROR: missing one or more fields in parameter definition.")
                err = 1
                continue

            current_param = Parameter()

            current_param.var = fields[0]
            current_param.dtype = fields[1]
            current_param.value = fields[2]

            # optional field: in namelist
            try:
                in_namelist = fields[3]
                if in_namelist in ["y", "Y"]:
                    current_param.in_namelist = True
                else:
                    current_param.in_namelist = False

            except:
                current_param.in_namelist = False


            # optional field: size -- this can have the form (var, module)
            # or just be a size
            try:
                size_info = fields[4]
                if size_info[0] == "(":
                    size, module = re.findall(r"\w+", size_info)
                else:
                    size = size_info
                    module = None

            except:
                size = 1
                module = None

            current_param.size = size
            current_param.module = module

            if not err == 1:
                params_list.append(current_param)

            line = get_next_line(f)

    return err, params_list


def abort(outfile):
    """ abort exits when there is an error.  A dummy stub file is written
    out, which will cause a compilation failure """

    fout = open(outfile, "w")
    fout.write("There was an error parsing the parameter files")
    fout.close()
    sys.exit(1)


def write_probin(probin_template, default_prob_param_file, prob_param_file, out_file, cxx_prefix):

    """ write_probin will read through the list of parameter files and
    output the new out_file """

    # read the parameters defined in the parameter files

    err, params = parse_param_file(default_prob_param_file, prob_param_file)
    if err:
        abort(out_file)

    # open up the template
    try:
        ftemplate = open(probin_template, "r")
    except IOError:
        sys.exit("write_probdata.py: ERROR: file {} does not exist".format(probin_template))

    template_lines = ftemplate.readlines()

    ftemplate.close()

    # output the template, inserting the parameter info in between the @@...@@
    fout = open(out_file, "w")

    fout.write(HEADER)

    for line in template_lines:

        index = line.find("@@")

        if index >= 0:
            index2 = line.rfind("@@")

            keyword = line[index+len("@@"):index2]
            indent = index*" "

            if keyword == "usestatements":
                # figure out the modules we need and then the unique
                # set of variables for those modules
                modules = set([q.module for q in params])
                for m in modules:
                    if m is None:
                        continue
                    mvars = ",".join(set([q.size for q in params if q.module == m]))

                    fout.write("{}use {}, only : {}\n".format(indent, m, mvars))

            elif keyword == "declarations":

                # declaraction statements
                for p in params:
                    if p.dtype == "character":
                        if p.is_array():
                            print("error, cannot have character arrays")
                            abort(out_file)
                        else:
                            fout.write("{}{}, public :: {}\n".format(
                                indent, p.get_f90_decl(), p.var))

                    else:
                        if p.is_array():
                            fout.write("{}{}, allocatable, public :: {}(:)\n".format(
                                indent, p.get_f90_decl(), p.var))
                        else:
                            fout.write("{}{}, allocatable, public :: {}\n".format(
                                indent, p.get_f90_decl(), p.var))

            elif keyword == "cudaattributes":
                for p in params:
                    if p.dtype != "character":
                        fout.write("{}attributes(managed) :: {}\n".format(indent, p.var))

            elif keyword == "namelist_vars":
                for p in params:
                    if p.in_namelist:
                        fout.write("{}namelist /fortin/ {}\n".format(indent, p.var))

            elif keyword == "namelist_gets":
                # Write the bit that reads the namelist, but only if any parameter
                # is actually in the namelist (otherwise this code wouldn't compile).
                namelist_used = False
                for p in params:
                    if p.in_namelist:
                        namelist_used = True
                        break

                if namelist_used:
                    fout.write("  ! read in the namelist\n")
                    fout.write("  open (newunit=un, file=probin_file(1:namlen), form='formatted', status='old')\n")
                    fout.write("  read (unit=un, nml=fortin, iostat=status)\n\n")
                    fout.write("  if (status < 0) then\n")
                    fout.write("    ! the namelist does not exist, so we just go with the defaults\n")
                    fout.write("    continue\n\n")
                    fout.write("  else if (status > 0) then\n")
                    fout.write("    ! some problem in the namelist\n")
                    fout.write("    call castro_error(\"ERROR: problem in the fortin namelist\")\n")
                    fout.write("  endif\n\n")
                    fout.write("  close (unit=un)\n\n")

            elif keyword == "allocations":
                for p in params:
                    if p.dtype != "character":
                        if p.is_array():
                            fout.write("{}allocate({}({}))\n".format(indent, p.var, p.size))
                        else:
                            fout.write("{}allocate({})\n".format(indent, p.var))

            elif keyword == "deallocations":
                for p in params:
                    if p.dtype != "character":
                        fout.write("{}deallocate({})\n".format(indent, p.var))

            elif keyword == "defaults":
                for p in params:
                    if p.is_array():
                        fout.write("{}{}(:) = {}\n".format(indent, p.var, p.value))
                    else:
                        fout.write("{}{} = {}\n".format(indent, p.var, p.value))

            elif keyword == "printing":

                fout.write("100 format (1x, a3, 2x, a32, 1x, \"=\", 1x, a)\n")
                fout.write("101 format (1x, a3, 2x, a32, 1x, \"=\", 1x, i10)\n")
                fout.write("102 format (1x, a3, 2x, a32, 1x, \"=\", 1x, g20.10)\n")
                fout.write("103 format (1x, a3, 2x, a32, 1x, \"=\", 1x, l)\n")

                for p in params:
                    if not p.in_namelist:
                        continue

                    if p.dtype == "logical":
                        ltest = "\n{}ltest = {} .eqv. {}\n".format(indent, p.var, p.value)
                    else:
                        ltest = "\n{}ltest = {} == {}\n".format(indent, p.var, p.value)

                    fout.write(ltest)

                    cmd = "merge(\"   \", \"[*]\", ltest)"

                    if p.dtype == "real":
                        fout.write("{}write (unit,102) {}, &\n \"{}\", {}\n".format(
                            indent, cmd, p.var, p.var))

                    elif p.dtype == "character":
                        fout.write("{}write (unit,100) {}, &\n \"{}\", trim({})\n".format(
                            indent, cmd, p.var, p.var))

                    elif p.dtype == "integer":
                        fout.write("{}write (unit,101) {}, &\n \"{}\", {}\n".format(
                            indent, cmd, p.var, p.var))

                    elif p.dtype == "logical":
                        fout.write("{}write (unit,103) {}, &\n \"{}\", {}\n".format(
                            indent, cmd, p.var, p.var))

                    else:
                        print("write_probdata.py: invalid datatype for variable {}".format(p.var))


            elif keyword == "cxx_gets":
                # this writes out the Fortran functions that can be called from C++
                # to get the value of the parameters.

                for p in params:
                    # We don't currently support the case where a module
                    # is required since we have no C++ equivalent for the module.
                    if p.is_array() and p.has_module():
                        continue
                    if p.dtype == "logical":
                        continue

                    if p.dtype == "character":
                        fout.write("{}subroutine get_f90_{}_len(slen) bind(C, name=\"get_f90_{}_len\")\n".format(
                            indent, p.var, p.var))
                        fout.write("{}   integer, intent(inout) :: slen\n".format(indent))
                        fout.write("{}   slen = len(trim({}))\n".format(indent, p.var))
                        fout.write("{}end subroutine get_f90_{}_len\n\n".format(indent, p.var))

                        fout.write("{}subroutine get_f90_{}({}_in) bind(C, name=\"get_f90_{}\")\n".format(
                            indent, p.var, p.var, p.var))
                        fout.write("{}   character(kind=c_char) :: {}_in(*)\n".format(
                            indent, p.var))
                        fout.write("{}   integer :: n\n".format(indent))
                        fout.write("{}   do n = 1, len(trim({}))\n".format(indent, p.var))
                        fout.write("{}      {}_in(n:n) = {}(n:n)\n".format(indent, p.var, p.var))
                        fout.write("{}   end do\n".format(indent))
                        fout.write("{}   {}_in(len(trim({}))+1) = char(0)\n".format(indent, p.var, p.var))
                        fout.write("{}end subroutine get_f90_{}\n\n".format(indent, p.var))

                    else:
                        fout.write("{}subroutine get_f90_{}({}_in) bind(C, name=\"get_f90_{}\")\n".format(
                            indent, p.var, p.var, p.var))
                        if p.is_array():
                            fout.write("{}   {}, intent(inout) :: {}_in({})\n".format(
                                indent, p.get_f90_decl(), p.var, p.size))
                        else:
                            fout.write("{}   {}, intent(inout) :: {}_in\n".format(
                                indent, p.get_f90_decl(), p.var))
                        fout.write("{}   {}_in = {}\n".format(
                            indent, p.var, p.var))
                        fout.write("{}end subroutine get_f90_{}\n\n".format(
                            indent, p.var))

            elif keyword == "cxx_sets":
                # this writes out the Fortran functions that can be called from C++
                # to set the value of the parameters.

                for p in params:
                    if p.is_array() and p.has_module():
                        continue
                    if p.dtype == "logical" or p.dtype == "character":
                        continue

                    fout.write("{}subroutine set_f90_{}({}_in) bind(C, name=\"set_f90_{}\")\n".format(
                        indent, p.var, p.var, p.var))
                    if p.is_array():
                        fout.write("{}   {}, intent(in) :: {}_in({})\n".format(
                            indent, p.get_f90_decl(), p.var, p.size))
                    else:
                        fout.write("{}   {}, intent(in) :: {}_in\n".format(
                            indent, p.get_f90_decl(), p.var))
                    fout.write("{}   {} = {}_in\n".format(
                        indent, p.var, p.var))
                    fout.write("{}end subroutine set_f90_{}\n\n".format(
                        indent, p.var))

        else:
            fout.write(line)

    print(" ")
    fout.close()

    # now handle the C++ -- we need to write a header and a .cpp file
    # for the parameters + a _F.H file for the Fortran communication

    # first the _F.H file
    ofile = "{}_parameters_F.H".format(cxx_prefix)
    with open(ofile, "w") as fout:
        fout.write(CXX_F_HEADER)

        for p in params:
            if p.is_array() and p.has_module():
                continue

            if p.dtype == "character":
                fout.write("  void get_f90_{}(char* {});\n\n".format(
                    p.var, p.var))
                fout.write("  void get_f90_{}_len(int& slen);\n\n".format(p.var))
                fout.write("  void set_f90_{}_len(int& slen);\n\n".format(p.var))

            else:
                fout.write("  void get_f90_{}({}* {});\n\n".format(
                    p.var, p.get_cxx_decl(), p.var))
                fout.write("  void set_f90_{}({}* {});\n\n".format(
                    p.var, p.get_cxx_decl(), p.var))

        fout.write(CXX_F_FOOTER)

    # now the main C++ header with the global data
    ofile = "{}_parameters.H".format(cxx_prefix)
    with open(ofile, "w") as fout:
        fout.write(CXX_HEADER)

        fout.write("  void init_{}_parameters();\n\n".format(os.path.basename(cxx_prefix)))

        fout.write("  namespace problem {\n\n")

        for p in params:
            if p.is_array() and p.has_module():
                continue

            if p.dtype == "character":
                fout.write("  extern std::string {};\n\n".format(p.var))
            else:
                if p.is_array():
                    fout.write("  extern AMREX_GPU_MANAGED {} {}[{}];\n\n".format(p.get_cxx_decl(), p.var, p.size))
                else:
                    fout.write("  extern AMREX_GPU_MANAGED {} {};\n\n".format(p.get_cxx_decl(), p.var))

        fout.write("  }\n\n")

        fout.write(CXX_FOOTER)

    # finally the C++ initialization routines
    ofile = "{}_parameters.cpp".format(cxx_prefix)
    with open(ofile, "w") as fout:
        fout.write("#include <{}_parameters.H>\n".format(os.path.basename(cxx_prefix)))
        fout.write("#include <{}_parameters_F.H>\n\n".format(os.path.basename(cxx_prefix)))

        for p in params:
            if p.is_array() and p.has_module():
                continue
            if p.dtype == "logical":
                continue

            if p.dtype == "character":
                fout.write("  std::string problem::{};\n\n".format(p.var))
            else:
                if p.is_array():
                    fout.write("  AMREX_GPU_MANAGED {} problem::{}[{}];\n\n".format(p.get_cxx_decl(), p.var, p.size))
                else:
                    fout.write("  AMREX_GPU_MANAGED {} problem::{};\n\n".format(p.get_cxx_decl(), p.var))

        fout.write("\n")
        fout.write("  void init_{}_parameters() {{\n".format(os.path.basename(cxx_prefix)))
        fout.write("    int slen = 0;\n\n")

        for p in params:
            if p.is_array() and p.has_module():
                continue
            if p.dtype == "logical":
                continue

            if p.dtype == "character":
                fout.write("    get_f90_{}_len(slen);\n".format(p.var))
                fout.write("    char _{}[slen+1];\n".format(p.var))
                fout.write("    get_f90_{}(_{});\n".format(p.var, p.var))
                fout.write("    problem::{} = std::string(_{});\n\n".format(p.var, p.var))
            else:
                if p.is_array():
                    fout.write("    get_f90_{}(problem::{});\n\n".format(p.var, p.var))
                else:
                    fout.write("    get_f90_{}(&problem::{});\n\n".format(p.var, p.var))

        fout.write("  }\n")

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('-t', type=str, help='probin_template')
    parser.add_argument('-o', type=str, help='out_file')
    parser.add_argument('-d', type=str, help='default parameter file name')
    parser.add_argument('-p', type=str, help='problem parameter file name')
    parser.add_argument('--cxx_prefix', type=str, default="prob",
                        help="a name to use in the C++ file names")

    args = parser.parse_args()

    probin_template = args.t
    out_file = args.o
    default_prob_params = args.d
    prob_params = args.p

    if probin_template == "" or out_file == "":
        sys.exit("write_probdata.py: ERROR: invalid calling sequence")

    write_probin(probin_template, default_prob_params, prob_params, out_file, args.cxx_prefix)

if __name__ == "__main__":
    main()
