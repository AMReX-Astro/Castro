#!/usr/bin/env python3

"""This routine parses plain-text parameter files that list runtime
parameters for use in our codes.  The general format of a parameter
is:

max_step                            integer            1
small_dt                            real               1.d-10
xlo_boundary_type                   character          ""
octant                              logical            .false.

This specifies the parameter name, datatype, and default
value.

The optional 4th column indicates whether the parameter appears
in the fortin namelist ("y" or "Y").

If the parameter is an array, the optional 5th column indicates the size of
the array.

This script takes a template file and replaces keywords in it
(delimited by @@...@@) with the Fortran code required to
initialize the parameters, setup a namelist, set the defaults, etc.

Note: there are two types of parameters here, the ones that are in the
namelist are true runtime parameters.  The non-namelist parameters
should be avoided if at all possible.

"""

import argparse
import os
import re
import sys

import runtime_parameters as rp

HEADER = """
! DO NOT EDIT THIS FILE!!!
!
! This file is automatically generated by write_probdata.py at
! compile-time.
!
! To add a runtime parameter, do so by editting the appropriate _prob_params
! file.

"""

CXX_F_HEADER = """
#ifndef problem_parameters_F_H
#define problem_parameters_F_H
#include <AMReX.H>
#include <AMReX_BLFort.H>

#ifdef __cplusplus
#include <AMReX.H>
extern "C"
{
#endif

void probdata_init(const int* name, const int* namlen);
"""

CXX_F_FOOTER = """
#ifdef __cplusplus
}
#endif

#endif
"""

CXX_HEADER = """
#ifndef problem_parameters_H
#define problem_parameters_H
#include <AMReX_BLFort.H>

#include <network_properties.H>

"""

CXX_FOOTER = """
#endif
"""

def get_next_line(fin):
    """return the next, non-blank line, with comments stripped"""
    line = fin.readline()

    pos = line.find("#")

    while (pos == 0 or line.strip() == "") and line:
        line = fin.readline()
        pos = line.find("#")

    return line[:pos]


def parse_param_file(prob_param_files):
    """read all the parameters in the prob_param_files and add valid
    parameters to the params list.  This returns the parameter list.

    """

    err = 0
    params_list = []

    for param_file in prob_param_files:

        try:
            f = open(param_file, "r")
        except FileNotFoundError:
            sys.exit(f"write_probdata.py: ERROR: file {param_file} does not exist")

        line = get_next_line(f)

        while line and not err:

            # this splits the line into separate fields.  A field is a
            # single word or a pair in parentheses like "(a, b)"
            fields = re.findall(r'[\w\"\+\./\-]+|\([\w+\./\-]+\s*,\s*[\w\+\.\-]+\)', line)

            if len(fields) < 3:
                print("write_probdata.py: ERROR: missing one or more fields in parameter definition.")
                err = 1
                continue


            name = fields[0]
            dtype = fields[1]
            default = fields[2]

            # optional field: in namelist
            try:
                in_namelist_in = fields[3]
                if in_namelist_in in ["y", "Y"]:
                    in_namelist = True
                else:
                    in_namelist = False

            except IndexError:
                in_namelist = False


            # optional field: size
            try:
                size = fields[4]
            except IndexError:
                size = 1

            current_param = rp.Param(name, dtype, default,
                                     namespace="problem",
                                     in_fortran=1)

            current_param.in_namelist = in_namelist
            current_param.size = size

            # check to see if this parameter is defined in the current
            # list if we delete the old one and take the new one (we
            # assume that later files automatically have higher
            # priority)
            p_names = [p.name for p in params_list]
            try:
                idx = p_names.index(current_param.name)
            except ValueError:
                pass
            else:
                params_list.pop(idx)

            if not err == 1:
                params_list.append(current_param)

            line = get_next_line(f)

    return err, params_list


def abort(outfile):
    """ abort exits when there is an error.  A dummy stub file is written
    out, which will cause a compilation failure """

    fout = open(outfile, "w")
    fout.write("There was an error parsing the parameter files")
    fout.close()
    sys.exit(1)

def write_probin(probin_template, prob_param_files,
                 out_file, cxx_prefix):
    """write_probin will read through the list of parameter files and
    output the new out_file

    """

    # read the parameters defined in the parameter files

    err, params = parse_param_file(prob_param_files)
    if err:
        abort(out_file)

    # open up the template
    try:
        ftemplate = open(probin_template, "r")
    except IOError:
        sys.exit(f"write_probdata.py: ERROR: file {probin_template} does not exist")

    template_lines = ftemplate.readlines()

    ftemplate.close()

    # output the template, inserting the parameter info in between the @@...@@
    fout = open(out_file, "w")

    fout.write(HEADER)

    for line in template_lines:

        index = line.find("@@")

        if index >= 0:
            index2 = line.rfind("@@")

            keyword = line[index+len("@@"):index2]
            indent = index*" "

            if keyword == "declarations":

                # declaraction statements
                for p in params:
                    fout.write(f"{indent}{p.get_f90_decl_string()}")

            elif keyword == "allocations":
                for p in params:
                    fout.write(p.get_f90_default_string())

            elif keyword == "namelist_vars":
                for p in params:
                    if p.in_namelist:
                        fout.write(f"{indent}namelist /fortin/ {p.name}\n")

            elif keyword == "namelist_gets":
                # Write the bit that reads the namelist, but only if any parameter
                # is actually in the namelist (otherwise this code wouldn't compile).
                namelist_used = any([q.in_namelist for q in params])

                if namelist_used:
                    fout.write("  ! read in the namelist\n")
                    fout.write("  open (newunit=un, file=probin_file(1:namlen), form='formatted', status='old')\n")
                    fout.write("  read (unit=un, nml=fortin, iostat=status)\n\n")
                    fout.write("  if (status < 0) then\n")
                    fout.write("    ! the namelist does not exist, so we just go with the defaults\n")
                    fout.write("    continue\n\n")
                    fout.write("  else if (status > 0) then\n")
                    fout.write("    ! some problem in the namelist\n")
                    fout.write("    call castro_error(\"ERROR: problem in the fortin namelist\")\n")
                    fout.write("  endif\n\n")
                    fout.write("  close (unit=un)\n\n")

            elif keyword == "printing":

                fout.write("100 format (1x, a3, 2x, a32, 1x, \"=\", 1x, a)\n")
                fout.write("101 format (1x, a3, 2x, a32, 1x, \"=\", 1x, i10)\n")
                fout.write("102 format (1x, a3, 2x, a32, 1x, \"=\", 1x, g20.10)\n")
                fout.write("103 format (1x, a3, 2x, a32, 1x, \"=\", 1x, l)\n")

                for p in params:
                    if not p.in_namelist:
                        continue

                    if p.dtype == "logical":
                        ltest = f"\n{indent}ltest = {p.name} .eqv. {p.default}\n"
                    else:
                        ltest = f"\n{indent}ltest = {p.name} == {p.default}\n"

                    fout.write(ltest)

                    cmd = "merge(\"   \", \"[*]\", ltest)"

                    if p.dtype == "real":
                        fout.write(f"{indent}write (unit,102) {cmd}, &\n \"{p.name}\", {p.name}\n")

                    elif p.dtype == "string":
                        fout.write(f"{indent}write (unit,100) {cmd}, &\n \"{p.name}\", trim({p.name})\n")

                    elif p.dtype == "integer":
                        fout.write(f"{indent}write (unit,101) {cmd}, &\n \"{p.name}\", {p.name}\n")

                    elif p.dtype == "logical":
                        fout.write(f"{indent}write (unit,103) {cmd}, &\n \"{p.name}\", {p.name}\n")

                    else:
                        print(f"write_probdata.py: invalid datatype for variable {p.name}")


            elif keyword == "cxx_gets":
                # this writes out the Fortran functions that can be
                # called from C++ to get the value of the parameters.

                for p in params:
                    fout.write(p.get_f90_get_function())

            elif keyword == "cxx_sets":
                # this writes out the Fortran functions that can be called from C++
                # to set the value of the parameters.

                for p in params:
                    if p.dtype == "logical" or p.dtype == "string":
                        continue

                    fout.write(f"  subroutine set_f90_{p.name}({p.name}_in) bind(C, name=\"set_f90_{p.name}\")\n")
                    if p.is_array():
                        fout.write(f"     {p.get_f90_decl()}, intent(in) :: {p.name}_in({p.size})\n")
                    else:
                        fout.write(f"     {p.get_f90_decl()}, intent(in) :: {p.name}_in\n")
                    fout.write(f"     {p.name} = {p.name}_in\n")
                    fout.write(f"  end subroutine set_f90_{p.name}\n\n")

        else:
            fout.write(line)

    print(" ")
    fout.close()

    # now handle the C++ -- we need to write a header and a .cpp file
    # for the parameters + a _F.H file for the Fortran communication

    # first the _F.H file
    ofile = f"{cxx_prefix}_parameters_F.H"
    with open(ofile, "w") as fout:
        fout.write(CXX_F_HEADER)

        for p in params:
            if p.dtype == "string":
                fout.write(f"  void get_f90_{p.name}(char* {p.name});\n\n")
                fout.write(f"  void get_f90_{p.name}_len(int& slen);\n\n")
                fout.write(f"  void set_f90_{p.name}_len(int& slen);\n\n")

            else:
                fout.write(f"  void get_f90_{p.name}({p.get_cxx_decl()}* {p.name});\n\n")
                fout.write(f"  void set_f90_{p.name}({p.get_cxx_decl()}* {p.name});\n\n")

        fout.write(CXX_F_FOOTER)

    # now the main C++ header with the global data
    cxx_base = os.path.basename(cxx_prefix)

    ofile = f"{cxx_prefix}_parameters.H"
    with open(ofile, "w") as fout:
        fout.write(CXX_HEADER)

        fout.write(f"  void init_{cxx_base}_parameters();\n\n")

        fout.write(f"  void cxx_to_f90_{cxx_base}_parameters();\n\n")

        fout.write("  namespace problem {\n\n")

        for p in params:
            if p.dtype == "string":
                fout.write(f"  extern std::string {p.name};\n\n")
            else:
                if p.is_array():
                    if p.size == "nspec":
                        fout.write(f"  extern AMREX_GPU_MANAGED {p.get_cxx_decl()} {p.name}[NumSpec];\n\n")
                    else:
                        fout.write(f"  extern AMREX_GPU_MANAGED {p.get_cxx_decl()} {p.name}[{p.size}];\n\n")
                else:
                    fout.write(f"  extern AMREX_GPU_MANAGED {p.get_cxx_decl()} {p.name};\n\n")

        fout.write("  }\n\n")

        fout.write(CXX_FOOTER)

    # finally the C++ initialization routines
    ofile = f"{cxx_prefix}_parameters.cpp"
    with open(ofile, "w") as fout:
        fout.write(f"#include <{cxx_base}_parameters.H>\n")
        fout.write(f"#include <{cxx_base}_parameters_F.H>\n\n")

        for p in params:
            if p.dtype == "logical":
                continue

            if p.dtype == "string":
                fout.write(f"  std::string problem::{p.name};\n\n")
            else:
                if p.is_array():
                    if p.size == "nspec":
                        fout.write(f"  AMREX_GPU_MANAGED {p.get_cxx_decl()} problem::{p.name}[NumSpec];\n\n")
                    else:
                        fout.write(f"  AMREX_GPU_MANAGED {p.get_cxx_decl()} problem::{p.name}[{p.size}];\n\n")
                else:
                    fout.write(f"  AMREX_GPU_MANAGED {p.get_cxx_decl()} problem::{p.name};\n\n")

        fout.write("\n")
        fout.write(f"  void init_{cxx_base}_parameters() {{\n")

        for p in params:
            if p.dtype == "logical":
                continue

            if p.dtype == "string":
                fout.write(f"    int slen_{p.name} = 0;\n")
                fout.write(f"    get_f90_{p.name}_len(slen_{p.name});\n")
                fout.write(f"    char _{p.name}[slen_{p.name}+1];\n")
                fout.write(f"    get_f90_{p.name}(_{p.name});\n")
                fout.write(f"    problem::{p.name} = std::string(_{p.name});\n\n")
            else:
                if p.is_array():
                    fout.write(f"    get_f90_{p.name}(problem::{p.name});\n\n")
                else:
                    fout.write(f"    get_f90_{p.name}(&problem::{p.name});\n\n")

        fout.write("  }\n")

        fout.write("\n")
        fout.write(f"  void cxx_to_f90_{cxx_base}_parameters() {{\n")
        fout.write("    int slen = 0;\n\n")

        for p in params:
            if p.dtype == "logical" or p.dtype == "string":
                continue

            if p.is_array():
                fout.write(f"    set_f90_{p.name}(problem::{p.name});\n\n")
            else:
                fout.write(f"    set_f90_{p.name}(&problem::{p.name});\n\n")

        fout.write("  }\n")


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('-t', type=str, help='probin_template')
    parser.add_argument('-o', type=str, help='out_file')
    parser.add_argument('-p', type=str, help='problem parameter file names (space separated in quotes)')
    parser.add_argument('--cxx_prefix', type=str, default="prob",
                        help="a name to use in the C++ file names")

    args = parser.parse_args()

    probin_template = args.t
    out_file = args.o
    prob_params = args.p.split()

    if probin_template == "" or out_file == "":
        sys.exit("write_probdata.py: ERROR: invalid calling sequence")

    write_probin(probin_template, prob_params, out_file, args.cxx_prefix)

if __name__ == "__main__":
    main()
