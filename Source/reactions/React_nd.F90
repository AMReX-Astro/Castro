module reactions_module

  use amrex_fort_module, only : rt => amrex_real
  implicit none

  public

contains

  subroutine ca_react_state(lo, hi, &
                            state, s_lo, s_hi, &
                            reactions, r_lo, r_hi, &
                            time, dt_react, &
                            failed) bind(C, name="ca_react_state")

    use network           , only : nspec, naux
    use meth_params_module, only : NVAR, URHO, UEDEN, UEINT, UTEMP, &
                                   UFS
#if NAUX_NET > 0
    use meth_params_module, only : UFX
#endif
#ifdef SHOCK_VAR
    use meth_params_module, only : USHK, disable_shock_burning
#endif
#ifdef AMREX_USE_ACC
    use meth_params_module, only : do_acc
#endif
    use prob_params_module, only : dx_level, dim
    use amrinfo_module, only : amr_level
    use burner_module
    use burn_type_module
    use react_util_module, only: okay_to_burn_type ! function
    use amrex_constants_module
    use eos_module, only: eos
    use eos_type_module, only: eos_t, eos_input_re
    use amrex_fort_module, only : rt => amrex_real
    use reduction_module, only: reduce_add

    implicit none

    integer , intent(in   ) :: lo(3), hi(3)
    integer , intent(in   ) :: s_lo(3), s_hi(3)
    integer , intent(in   ) :: r_lo(3), r_hi(3)
    real(rt), intent(inout) :: state(s_lo(1):s_hi(1),s_lo(2):s_hi(2),s_lo(3):s_hi(3),NVAR)
    real(rt), intent(inout) :: reactions(r_lo(1):r_hi(1),r_lo(2):r_hi(2),r_lo(3):r_hi(3),nspec+naux+2)
    real(rt), intent(in   ), value :: time, dt_react
    real(rt) , intent(inout) :: failed

    integer          :: i, j, k, n
    real(rt)         :: rhoInv
    logical          :: do_burn

    type (burn_t) :: burn_state_in, burn_state_out

    real(rt) :: failed_tmp

    !$gpu

    ! This interface is currently unsupported with simplified SDC.
#ifndef SIMPLIFIED_SDC

    !$acc data &
    !$acc copyin(lo, hi, r_lo, r_hi, s_lo, s_hi, dt_react, time) &
    !$acc copy(state, reactions) if(do_acc == 1)

    !$acc parallel if(do_acc == 1)

    !$acc loop gang vector collapse(3) &
    !$acc private(rhoInv) &
    !$acc private(burn_state_in, burn_state_out) &
    !$acc private(i,j,k)

    do k = lo(3), hi(3)
       do j = lo(2), hi(2)
          do i = lo(1), hi(1)

             ! Initialize some data for later.

             do_burn = .true.
             burn_state_in % success = .true.
             burn_state_out % success = .true.

             ! Don't burn on zones inside shock regions, if the relevant option is set.

#ifdef SHOCK_VAR
             if (state(i,j,k,USHK) > ZERO .and. disable_shock_burning == 1) then
                do_burn = .false.
             end if
#endif

             rhoInv = ONE / state(i,j,k,URHO)

             burn_state_in % rho = state(i,j,k,URHO)
             burn_state_in % T   = state(i,j,k,UTEMP)
             burn_state_in % e   = ZERO ! Energy generated by the burn

             do n = 1, nspec
                burn_state_in % xn(n) = state(i,j,k,UFS+n-1) * rhoInv
             enddo

#if NAUX_NET > 0
             do n = 1, naux
                burn_state_in % aux(n) = state(i,j,k,UFX+n-1) * rhoInv
             enddo
#endif

             if (i >= lo(1) .and. i <= hi(1)) then
                burn_state_in % i = i
             else
                burn_state_in % i = -1
             endif

             if (j >= lo(2) .and. j <= hi(2)) then 
                burn_state_in % j = j
             else
                burn_state_in % j = -1
             endif

             if (k >= lo(3) .and. k <= hi(3)) then
                burn_state_in % k = k
             else
                burn_state_in % k = -1
             endif

             ! Ensure we start with no RHS or Jacobian calls registered.

             burn_state_in % n_rhs = 0
             burn_state_in % n_jac = 0

             ! Don't burn if we're outside of the relevant (rho, T) range.

             if (.not. okay_to_burn_type(burn_state_in)) then
                do_burn = .false.
             end if

             ! Initialize the final state by assuming it does not change.

             call copy_burn_t(burn_state_out, burn_state_in)

             if (do_burn) then
                call burner(burn_state_in, burn_state_out, dt_react, time)
             end if

             ! If we were unsuccessful, update the failure flag.

             failed_tmp = 0.0_rt

             if (.not. burn_state_out % success) then

                failed_tmp = 1.0_rt

             end if

             call reduce_add(failed, failed_tmp)

             if (do_burn) then

                ! Add burning rates to reactions MultiFab, but be
                ! careful because the reactions and state MFs may
                ! not have the same number of ghost cells.

                if ( i .ge. r_lo(1) .and. i .le. r_hi(1) .and. &
                     j .ge. r_lo(2) .and. j .le. r_hi(2) .and. &
                     k .ge. r_lo(3) .and. k .le. r_hi(3) ) then

                   do n = 1, nspec
                      reactions(i,j,k,n) = state(i,j,k,URHO) * (burn_state_out % xn(n) - burn_state_in % xn(n)) / dt_react
                   end do
#if NAUX_NET > 0
                   do n = 1, naux
                      reactions(i,j,k,n+nspec) = state(i,j,k,URHO) * (burn_state_out % aux(n) - burn_state_in % aux(n)) / dt_react
                   end do
#endif
                   reactions(i,j,k,nspec+naux+1) = state(i,j,k,URHO) * (burn_state_out % e - burn_state_in % e) / dt_react
                   reactions(i,j,k,nspec+naux+2) = max(ONE, dble(burn_state_out % n_rhs + 2 * burn_state_out % n_jac))

                end if

             else

                if ( i .ge. r_lo(1) .and. i .le. r_hi(1) .and. &
                     j .ge. r_lo(2) .and. j .le. r_hi(2) .and. &
                     k .ge. r_lo(3) .and. k .le. r_hi(3) ) then

                   do n = 1, nspec+naux+1
                      reactions(i,j,k,n) = ZERO
                   end do

                   reactions(i,j,k,nspec+naux+2) = ONE

                end if

             end if

          enddo
       enddo
    enddo

    !$acc end parallel

    !$acc end data

#endif

  end subroutine ca_react_state

end module reactions_module
